// Code generated by protoc-gen-go.
// source: kinetic.proto
// DO NOT EDIT!

/*
Package com_seagate_kinetic_proto is a generated protocol buffer package.

*
Copyright 2013-2016 Seagate Technology LLC.

This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at
https://mozilla.org/MP:/2.0/.

This program is distributed in the hope that it will be useful,
but is provided AS-IS, WITHOUT ANY WARRANTY; including without
the implied warranty of MERCHANTABILITY, NON-INFRINGEMENT or
FITNESS FOR A PARTICULAR PURPOSE. See the Mozilla Public
License for more details.

See www.openkinetic.org for more project information

It is generated from these files:
	kinetic.proto

It has these top-level messages:
	Local
	Message
	Command
*/
package com_seagate_kinetic_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The Message Type determines how the the message is to be processed.
type Message_AuthType int32

const (
	// if the message type is unknown, close the connection
	Message_INVALID_AUTH_TYPE Message_AuthType = -1
	// This is for normal traffic. Check the HMAC of the command and
	// if correct, process the command.
	Message_HMACAUTH Message_AuthType = 1
	// device unlock and ISE command. These must come over the TLS connection.
	// If they do not, close the connection. If it is over
	// the TLS connection, execute the pin operation.
	Message_PINAUTH Message_AuthType = 2
	// In the event that the device is going to close the connection, an
	// unsolicited status will be returned first.
	Message_UNSOLICITEDSTATUS Message_AuthType = 3
)

var Message_AuthType_name = map[int32]string{
	-1: "INVALID_AUTH_TYPE",
	1:  "HMACAUTH",
	2:  "PINAUTH",
	3:  "UNSOLICITEDSTATUS",
}
var Message_AuthType_value = map[string]int32{
	"INVALID_AUTH_TYPE": -1,
	"HMACAUTH":          1,
	"PINAUTH":           2,
	"UNSOLICITEDSTATUS": 3,
}

func (x Message_AuthType) Enum() *Message_AuthType {
	p := new(Message_AuthType)
	*p = x
	return p
}
func (x Message_AuthType) String() string {
	return proto.EnumName(Message_AuthType_name, int32(x))
}
func (x *Message_AuthType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Message_AuthType_value, data, "Message_AuthType")
	if err != nil {
		return err
	}
	*x = Message_AuthType(value)
	return nil
}
func (Message_AuthType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type Command_Synchronization int32

const (
	Command_INVALID_SYNCHRONIZATION Command_Synchronization = -1
	Command_WRITETHROUGH            Command_Synchronization = 1
	Command_WRITEBACK               Command_Synchronization = 2
	Command_FLUSH                   Command_Synchronization = 3
)

var Command_Synchronization_name = map[int32]string{
	-1: "INVALID_SYNCHRONIZATION",
	1:  "WRITETHROUGH",
	2:  "WRITEBACK",
	3:  "FLUSH",
}
var Command_Synchronization_value = map[string]int32{
	"INVALID_SYNCHRONIZATION": -1,
	"WRITETHROUGH":            1,
	"WRITEBACK":               2,
	"FLUSH":                   3,
}

func (x Command_Synchronization) Enum() *Command_Synchronization {
	p := new(Command_Synchronization)
	*p = x
	return p
}
func (x Command_Synchronization) String() string {
	return proto.EnumName(Command_Synchronization_name, int32(x))
}
func (x *Command_Synchronization) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Synchronization_value, data, "Command_Synchronization")
	if err != nil {
		return err
	}
	*x = Command_Synchronization(value)
	return nil
}
func (Command_Synchronization) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type Command_Priority int32

const (
	Command_NORMAL  Command_Priority = 5
	Command_LOWEST  Command_Priority = 1
	Command_LOWER   Command_Priority = 3
	Command_HIGHER  Command_Priority = 7
	Command_HIGHEST Command_Priority = 9
)

var Command_Priority_name = map[int32]string{
	5: "NORMAL",
	1: "LOWEST",
	3: "LOWER",
	7: "HIGHER",
	9: "HIGHEST",
}
var Command_Priority_value = map[string]int32{
	"NORMAL":  5,
	"LOWEST":  1,
	"LOWER":   3,
	"HIGHER":  7,
	"HIGHEST": 9,
}

func (x Command_Priority) Enum() *Command_Priority {
	p := new(Command_Priority)
	*p = x
	return p
}
func (x Command_Priority) String() string {
	return proto.EnumName(Command_Priority_name, int32(x))
}
func (x *Command_Priority) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Priority_value, data, "Command_Priority")
	if err != nil {
		return err
	}
	*x = Command_Priority(value)
	return nil
}
func (Command_Priority) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

// algorithm
type Command_Algorithm int32

const (
	Command_INVALID_ALGORITHM Command_Algorithm = -1
	Command_SHA1              Command_Algorithm = 1
	Command_SHA2              Command_Algorithm = 2
	Command_SHA3              Command_Algorithm = 3
	Command_CRC32             Command_Algorithm = 4
	Command_CRC64             Command_Algorithm = 5
)

var Command_Algorithm_name = map[int32]string{
	-1: "INVALID_ALGORITHM",
	1:  "SHA1",
	2:  "SHA2",
	3:  "SHA3",
	4:  "CRC32",
	5:  "CRC64",
}
var Command_Algorithm_value = map[string]int32{
	"INVALID_ALGORITHM": -1,
	"SHA1":              1,
	"SHA2":              2,
	"SHA3":              3,
	"CRC32":             4,
	"CRC64":             5,
}

func (x Command_Algorithm) Enum() *Command_Algorithm {
	p := new(Command_Algorithm)
	*p = x
	return p
}
func (x Command_Algorithm) String() string {
	return proto.EnumName(Command_Algorithm_name, int32(x))
}
func (x *Command_Algorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Algorithm_value, data, "Command_Algorithm")
	if err != nil {
		return err
	}
	*x = Command_Algorithm(value)
	return nil
}
func (Command_Algorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 2} }

// operation code
type Command_MessageType int32

const (
	Command_INVALID_MESSAGE_TYPE Command_MessageType = -1
	Command_GET                  Command_MessageType = 2
	Command_GET_RESPONSE         Command_MessageType = 1
	Command_PUT                  Command_MessageType = 4
	Command_PUT_RESPONSE         Command_MessageType = 3
	Command_DELETE               Command_MessageType = 6
	Command_DELETE_RESPONSE      Command_MessageType = 5
	Command_GETNEXT              Command_MessageType = 8
	Command_GETNEXT_RESPONSE     Command_MessageType = 7
	Command_GETPREVIOUS          Command_MessageType = 10
	Command_GETPREVIOUS_RESPONSE Command_MessageType = 9
	Command_GETKEYRANGE          Command_MessageType = 12
	Command_GETKEYRANGE_RESPONSE Command_MessageType = 11
	// 13 and 14 are reserved, do not use
	Command_GETVERSION          Command_MessageType = 16
	Command_GETVERSION_RESPONSE Command_MessageType = 15
	// 17, 18, 19, and 20 are reserved, do not use
	Command_SETUP                  Command_MessageType = 22
	Command_SETUP_RESPONSE         Command_MessageType = 21
	Command_GETLOG                 Command_MessageType = 24
	Command_GETLOG_RESPONSE        Command_MessageType = 23
	Command_SECURITY               Command_MessageType = 26
	Command_SECURITY_RESPONSE      Command_MessageType = 25
	Command_PEER2PEERPUSH          Command_MessageType = 28
	Command_PEER2PEERPUSH_RESPONSE Command_MessageType = 27
	Command_NOOP                   Command_MessageType = 30
	Command_NOOP_RESPONSE          Command_MessageType = 29
	Command_FLUSHALLDATA           Command_MessageType = 32
	Command_FLUSHALLDATA_RESPONSE  Command_MessageType = 31
	// 33, 34 are reserved
	Command_PINOP          Command_MessageType = 36
	Command_PINOP_RESPONSE Command_MessageType = 35
	// Media scan is to check that the user data is readable, and
	// if the end to end integrity is known to the device, if the
	// end to end integrity field is correct.
	Command_MEDIASCAN          Command_MessageType = 38
	Command_MEDIASCAN_RESPONSE Command_MessageType = 37
	// This performs optimizations of the media. Things like
	// defragmentation, compaction, garbage collection, compression
	// could be things accomplished using the media optimize command.
	Command_MEDIAOPTIMIZE          Command_MessageType = 40
	Command_MEDIAOPTIMIZE_RESPONSE Command_MessageType = 39
	// batch operations
	Command_START_BATCH          Command_MessageType = 42
	Command_START_BATCH_RESPONSE Command_MessageType = 41
	Command_END_BATCH            Command_MessageType = 44
	Command_END_BATCH_RESPONSE   Command_MessageType = 43
	Command_ABORT_BATCH          Command_MessageType = 46
	Command_ABORT_BATCH_RESPONSE Command_MessageType = 45
)

var Command_MessageType_name = map[int32]string{
	-1: "INVALID_MESSAGE_TYPE",
	2:  "GET",
	1:  "GET_RESPONSE",
	4:  "PUT",
	3:  "PUT_RESPONSE",
	6:  "DELETE",
	5:  "DELETE_RESPONSE",
	8:  "GETNEXT",
	7:  "GETNEXT_RESPONSE",
	10: "GETPREVIOUS",
	9:  "GETPREVIOUS_RESPONSE",
	12: "GETKEYRANGE",
	11: "GETKEYRANGE_RESPONSE",
	16: "GETVERSION",
	15: "GETVERSION_RESPONSE",
	22: "SETUP",
	21: "SETUP_RESPONSE",
	24: "GETLOG",
	23: "GETLOG_RESPONSE",
	26: "SECURITY",
	25: "SECURITY_RESPONSE",
	28: "PEER2PEERPUSH",
	27: "PEER2PEERPUSH_RESPONSE",
	30: "NOOP",
	29: "NOOP_RESPONSE",
	32: "FLUSHALLDATA",
	31: "FLUSHALLDATA_RESPONSE",
	36: "PINOP",
	35: "PINOP_RESPONSE",
	38: "MEDIASCAN",
	37: "MEDIASCAN_RESPONSE",
	40: "MEDIAOPTIMIZE",
	39: "MEDIAOPTIMIZE_RESPONSE",
	42: "START_BATCH",
	41: "START_BATCH_RESPONSE",
	44: "END_BATCH",
	43: "END_BATCH_RESPONSE",
	46: "ABORT_BATCH",
	45: "ABORT_BATCH_RESPONSE",
}
var Command_MessageType_value = map[string]int32{
	"INVALID_MESSAGE_TYPE": -1,
	"GET":                    2,
	"GET_RESPONSE":           1,
	"PUT":                    4,
	"PUT_RESPONSE":           3,
	"DELETE":                 6,
	"DELETE_RESPONSE":        5,
	"GETNEXT":                8,
	"GETNEXT_RESPONSE":       7,
	"GETPREVIOUS":            10,
	"GETPREVIOUS_RESPONSE":   9,
	"GETKEYRANGE":            12,
	"GETKEYRANGE_RESPONSE":   11,
	"GETVERSION":             16,
	"GETVERSION_RESPONSE":    15,
	"SETUP":                  22,
	"SETUP_RESPONSE":         21,
	"GETLOG":                 24,
	"GETLOG_RESPONSE":        23,
	"SECURITY":               26,
	"SECURITY_RESPONSE":      25,
	"PEER2PEERPUSH":          28,
	"PEER2PEERPUSH_RESPONSE": 27,
	"NOOP":                   30,
	"NOOP_RESPONSE":          29,
	"FLUSHALLDATA":           32,
	"FLUSHALLDATA_RESPONSE":  31,
	"PINOP":                  36,
	"PINOP_RESPONSE":         35,
	"MEDIASCAN":              38,
	"MEDIASCAN_RESPONSE":     37,
	"MEDIAOPTIMIZE":          40,
	"MEDIAOPTIMIZE_RESPONSE": 39,
	"START_BATCH":            42,
	"START_BATCH_RESPONSE":   41,
	"END_BATCH":              44,
	"END_BATCH_RESPONSE":     43,
	"ABORT_BATCH":            46,
	"ABORT_BATCH_RESPONSE":   45,
}

func (x Command_MessageType) Enum() *Command_MessageType {
	p := new(Command_MessageType)
	*p = x
	return p
}
func (x Command_MessageType) String() string {
	return proto.EnumName(Command_MessageType_name, int32(x))
}
func (x *Command_MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_MessageType_value, data, "Command_MessageType")
	if err != nil {
		return err
	}
	*x = Command_MessageType(value)
	return nil
}
func (Command_MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 3} }

// enum of status code
type Command_Status_StatusCode int32

const (
	// Must come first, so default is invalid
	Command_Status_INVALID_STATUS_CODE Command_Status_StatusCode = -1
	//  for a P2P operation, there was a reason the list was incomplete. This is for items
	// that were not attempted.
	Command_Status_NOT_ATTEMPTED    Command_Status_StatusCode = 0
	Command_Status_SUCCESS          Command_Status_StatusCode = 1
	Command_Status_HMAC_FAILURE     Command_Status_StatusCode = 2
	Command_Status_NOT_AUTHORIZED   Command_Status_StatusCode = 3
	Command_Status_VERSION_FAILURE  Command_Status_StatusCode = 4
	Command_Status_INTERNAL_ERROR   Command_Status_StatusCode = 5
	Command_Status_HEADER_REQUIRED  Command_Status_StatusCode = 6
	Command_Status_NOT_FOUND        Command_Status_StatusCode = 7
	Command_Status_VERSION_MISMATCH Command_Status_StatusCode = 8
	// If there are too many requests in the device at this time, requests
	// will be rejected with this error message. The common response is to
	// wait and retry the operation with an exponential back-off.
	Command_Status_SERVICE_BUSY Command_Status_StatusCode = 9
	// A long operation was started and a timeout happened mid operation. This
	// does not imply a failure.
	Command_Status_EXPIRED Command_Status_StatusCode = 10
	// A data error happened and either earlyExit was set or the timeout happened.
	Command_Status_DATA_ERROR Command_Status_StatusCode = 11
	// A data error happened and all possible error recovery operations have been
	// performed. There is no value to trying this again. If the system has the ability
	// to determine the correct information, writing the data again can get rid
	Command_Status_PERM_DATA_ERROR Command_Status_StatusCode = 12
	// A TCP connection to the remote peer failed. This is only for the P2P Operation
	Command_Status_REMOTE_CONNECTION_ERROR Command_Status_StatusCode = 13
	// When the device is full, it returns this error. The background scrubbing may free space,
	// so this error may go away
	Command_Status_NO_SPACE Command_Status_StatusCode = 14
	// In the set security, an HmacAlgorithm was specified as Unknown or there is a protocol
	// version mis-match
	Command_Status_NO_SUCH_HMAC_ALGORITHM Command_Status_StatusCode = 15
	// The request is not valid. Subsequent attempts with the same request will return the same code.
	// Examples: GET does not specify keyValue message, GETKEYRANGE operation does not specify startKey, etc
	Command_Status_INVALID_REQUEST Command_Status_StatusCode = 16
	// For P2P Requests, the operation was executed successfully but some nested operations
	// did not succeed. This indicates that callers should review the status of nested operations.
	// This status should only be used in the Command > Status, not in the Status messages
	// of nested P2POperations
	Command_Status_NESTED_OPERATION_ERRORS Command_Status_StatusCode = 17
	// If the device is currently locked and can not validate
	// the hmac. This is returned as an status
	// and the connection is terminated.
	Command_Status_DEVICE_LOCKED Command_Status_StatusCode = 18
	// The device was already unlocked. The validity of the
	// pin was NOT checked. The connection remains open.
	Command_Status_DEVICE_ALREADY_UNLOCKED Command_Status_StatusCode = 19
	// The connection is being terminated. Details as to why are
	// in the message string.
	Command_Status_CONNECTION_TERMINATED Command_Status_StatusCode = 20
	// During a batch operation, the only operations allowed are put "
	// and delete. This error is put against the offending command and "
	// the rest of the commands and the END_BATCH return NOT_ATTEMPTED."
	Command_Status_INVALID_BATCH Command_Status_StatusCode = 21
)

var Command_Status_StatusCode_name = map[int32]string{
	-1: "INVALID_STATUS_CODE",
	0:  "NOT_ATTEMPTED",
	1:  "SUCCESS",
	2:  "HMAC_FAILURE",
	3:  "NOT_AUTHORIZED",
	4:  "VERSION_FAILURE",
	5:  "INTERNAL_ERROR",
	6:  "HEADER_REQUIRED",
	7:  "NOT_FOUND",
	8:  "VERSION_MISMATCH",
	9:  "SERVICE_BUSY",
	10: "EXPIRED",
	11: "DATA_ERROR",
	12: "PERM_DATA_ERROR",
	13: "REMOTE_CONNECTION_ERROR",
	14: "NO_SPACE",
	15: "NO_SUCH_HMAC_ALGORITHM",
	16: "INVALID_REQUEST",
	17: "NESTED_OPERATION_ERRORS",
	18: "DEVICE_LOCKED",
	19: "DEVICE_ALREADY_UNLOCKED",
	20: "CONNECTION_TERMINATED",
	21: "INVALID_BATCH",
}
var Command_Status_StatusCode_value = map[string]int32{
	"INVALID_STATUS_CODE":     -1,
	"NOT_ATTEMPTED":           0,
	"SUCCESS":                 1,
	"HMAC_FAILURE":            2,
	"NOT_AUTHORIZED":          3,
	"VERSION_FAILURE":         4,
	"INTERNAL_ERROR":          5,
	"HEADER_REQUIRED":         6,
	"NOT_FOUND":               7,
	"VERSION_MISMATCH":        8,
	"SERVICE_BUSY":            9,
	"EXPIRED":                 10,
	"DATA_ERROR":              11,
	"PERM_DATA_ERROR":         12,
	"REMOTE_CONNECTION_ERROR": 13,
	"NO_SPACE":                14,
	"NO_SUCH_HMAC_ALGORITHM":  15,
	"INVALID_REQUEST":         16,
	"NESTED_OPERATION_ERRORS": 17,
	"DEVICE_LOCKED":           18,
	"DEVICE_ALREADY_UNLOCKED": 19,
	"CONNECTION_TERMINATED":   20,
	"INVALID_BATCH":           21,
}

func (x Command_Status_StatusCode) Enum() *Command_Status_StatusCode {
	p := new(Command_Status_StatusCode)
	*p = x
	return p
}
func (x Command_Status_StatusCode) String() string {
	return proto.EnumName(Command_Status_StatusCode_name, int32(x))
}
func (x *Command_Status_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Status_StatusCode_value, data, "Command_Status_StatusCode")
	if err != nil {
		return err
	}
	*x = Command_Status_StatusCode(value)
	return nil
}
func (Command_Status_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 3, 0}
}

type Command_GetLog_Type int32

const (
	Command_GetLog_INVALID_TYPE  Command_GetLog_Type = -1
	Command_GetLog_UTILIZATIONS  Command_GetLog_Type = 0
	Command_GetLog_TEMPERATURES  Command_GetLog_Type = 1
	Command_GetLog_CAPACITIES    Command_GetLog_Type = 2
	Command_GetLog_CONFIGURATION Command_GetLog_Type = 3
	Command_GetLog_STATISTICS    Command_GetLog_Type = 4
	Command_GetLog_MESSAGES      Command_GetLog_Type = 5
	Command_GetLog_LIMITS        Command_GetLog_Type = 6
	Command_GetLog_DEVICE        Command_GetLog_Type = 7
)

var Command_GetLog_Type_name = map[int32]string{
	-1: "INVALID_TYPE",
	0:  "UTILIZATIONS",
	1:  "TEMPERATURES",
	2:  "CAPACITIES",
	3:  "CONFIGURATION",
	4:  "STATISTICS",
	5:  "MESSAGES",
	6:  "LIMITS",
	7:  "DEVICE",
}
var Command_GetLog_Type_value = map[string]int32{
	"INVALID_TYPE":  -1,
	"UTILIZATIONS":  0,
	"TEMPERATURES":  1,
	"CAPACITIES":    2,
	"CONFIGURATION": 3,
	"STATISTICS":    4,
	"MESSAGES":      5,
	"LIMITS":        6,
	"DEVICE":        7,
}

func (x Command_GetLog_Type) Enum() *Command_GetLog_Type {
	p := new(Command_GetLog_Type)
	*p = x
	return p
}
func (x Command_GetLog_Type) String() string {
	return proto.EnumName(Command_GetLog_Type_name, int32(x))
}
func (x *Command_GetLog_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_GetLog_Type_value, data, "Command_GetLog_Type")
	if err != nil {
		return err
	}
	*x = Command_GetLog_Type(value)
	return nil
}
func (Command_GetLog_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8, 0} }

type Command_Security_ACL_HMACAlgorithm int32

const (
	Command_Security_ACL_INVALID_HMAC_ALGORITHM Command_Security_ACL_HMACAlgorithm = -1
	// 0 is reserved; do not use
	Command_Security_ACL_HmacSHA1 Command_Security_ACL_HMACAlgorithm = 1
)

var Command_Security_ACL_HMACAlgorithm_name = map[int32]string{
	-1: "INVALID_HMAC_ALGORITHM",
	1:  "HmacSHA1",
}
var Command_Security_ACL_HMACAlgorithm_value = map[string]int32{
	"INVALID_HMAC_ALGORITHM": -1,
	"HmacSHA1":               1,
}

func (x Command_Security_ACL_HMACAlgorithm) Enum() *Command_Security_ACL_HMACAlgorithm {
	p := new(Command_Security_ACL_HMACAlgorithm)
	*p = x
	return p
}
func (x Command_Security_ACL_HMACAlgorithm) String() string {
	return proto.EnumName(Command_Security_ACL_HMACAlgorithm_name, int32(x))
}
func (x *Command_Security_ACL_HMACAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Security_ACL_HMACAlgorithm_value, data, "Command_Security_ACL_HMACAlgorithm")
	if err != nil {
		return err
	}
	*x = Command_Security_ACL_HMACAlgorithm(value)
	return nil
}
func (Command_Security_ACL_HMACAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 9, 0, 0}
}

type Command_Security_ACL_Permission int32

const (
	Command_Security_ACL_INVALID_PERMISSION Command_Security_ACL_Permission = -1
	Command_Security_ACL_READ               Command_Security_ACL_Permission = 0
	Command_Security_ACL_WRITE              Command_Security_ACL_Permission = 1
	Command_Security_ACL_DELETE             Command_Security_ACL_Permission = 2
	Command_Security_ACL_RANGE              Command_Security_ACL_Permission = 3
	Command_Security_ACL_SETUP              Command_Security_ACL_Permission = 4
	Command_Security_ACL_P2POP              Command_Security_ACL_Permission = 5
	Command_Security_ACL_GETLOG             Command_Security_ACL_Permission = 7
	Command_Security_ACL_SECURITY           Command_Security_ACL_Permission = 8
)

var Command_Security_ACL_Permission_name = map[int32]string{
	-1: "INVALID_PERMISSION",
	0:  "READ",
	1:  "WRITE",
	2:  "DELETE",
	3:  "RANGE",
	4:  "SETUP",
	5:  "P2POP",
	7:  "GETLOG",
	8:  "SECURITY",
}
var Command_Security_ACL_Permission_value = map[string]int32{
	"INVALID_PERMISSION": -1,
	"READ":               0,
	"WRITE":              1,
	"DELETE":             2,
	"RANGE":              3,
	"SETUP":              4,
	"P2POP":              5,
	"GETLOG":             7,
	"SECURITY":           8,
}

func (x Command_Security_ACL_Permission) Enum() *Command_Security_ACL_Permission {
	p := new(Command_Security_ACL_Permission)
	*p = x
	return p
}
func (x Command_Security_ACL_Permission) String() string {
	return proto.EnumName(Command_Security_ACL_Permission_name, int32(x))
}
func (x *Command_Security_ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Security_ACL_Permission_value, data, "Command_Security_ACL_Permission")
	if err != nil {
		return err
	}
	*x = Command_Security_ACL_Permission(value)
	return nil
}
func (Command_Security_ACL_Permission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 9, 0, 1}
}

type Command_PinOperation_PinOpType int32

const (
	Command_PinOperation_INVALID_PINOP Command_PinOperation_PinOpType = -1
	// The pin will unlock the device
	Command_PinOperation_UNLOCK_PINOP Command_PinOperation_PinOpType = 1
	// This will lock the device. This includes all
	// configuration and user data. This operation is
	// secure from even given physical access and
	// disassembly of the device.
	Command_PinOperation_LOCK_PINOP Command_PinOperation_PinOpType = 2
	// Erase the device. This may be secure
	// or not. The implication is that it may be faster
	// than the secure operation.
	Command_PinOperation_ERASE_PINOP Command_PinOperation_PinOpType = 3
	// Erase the device in a way that will
	// physical access and disassembly of the device
	// will not
	Command_PinOperation_SECURE_ERASE_PINOP Command_PinOperation_PinOpType = 4
)

var Command_PinOperation_PinOpType_name = map[int32]string{
	-1: "INVALID_PINOP",
	1:  "UNLOCK_PINOP",
	2:  "LOCK_PINOP",
	3:  "ERASE_PINOP",
	4:  "SECURE_ERASE_PINOP",
}
var Command_PinOperation_PinOpType_value = map[string]int32{
	"INVALID_PINOP":      -1,
	"UNLOCK_PINOP":       1,
	"LOCK_PINOP":         2,
	"ERASE_PINOP":        3,
	"SECURE_ERASE_PINOP": 4,
}

func (x Command_PinOperation_PinOpType) Enum() *Command_PinOperation_PinOpType {
	p := new(Command_PinOperation_PinOpType)
	*p = x
	return p
}
func (x Command_PinOperation_PinOpType) String() string {
	return proto.EnumName(Command_PinOperation_PinOpType_name, int32(x))
}
func (x *Command_PinOperation_PinOpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_PinOperation_PinOpType_value, data, "Command_PinOperation_PinOpType")
	if err != nil {
		return err
	}
	*x = Command_PinOperation_PinOpType(value)
	return nil
}
func (Command_PinOperation_PinOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 10, 0}
}

// this is a local message to allow the program to read
// the protocol version number by building this message
// and then reading the value.
type Local struct {
	ProtocolVersion  *string `protobuf:"bytes,1,opt,name=protocolVersion,def=3.0.6" json:"protocolVersion,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Local) Reset()                    { *m = Local{} }
func (m *Local) String() string            { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()               {}
func (*Local) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

const Default_Local_ProtocolVersion string = "3.0.6"

func (m *Local) GetProtocolVersion() string {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return Default_Local_ProtocolVersion
}

// THe message is an authorization and command bytes.
type Message struct {
	// Every message must be one of the following types.
	AuthType *Message_AuthType `protobuf:"varint,4,opt,name=authType,enum=com.seagate.kinetic.proto.Message_AuthType" json:"authType,omitempty"`
	// Normal messages
	HmacAuth *Message_HMACauth `protobuf:"bytes,5,opt,name=hmacAuth" json:"hmacAuth,omitempty"`
	// for Pin based operations. These include device unlock and
	// device erase
	PinAuth *Message_PINauth `protobuf:"bytes,6,opt,name=pinAuth" json:"pinAuth,omitempty"`
	// the embedded message providing the request (for HMACauth) and
	// the response (for all auth types).
	CommandBytes     []byte `protobuf:"bytes,7,opt,name=commandBytes" json:"commandBytes,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Message) GetAuthType() Message_AuthType {
	if m != nil && m.AuthType != nil {
		return *m.AuthType
	}
	return Message_INVALID_AUTH_TYPE
}

func (m *Message) GetHmacAuth() *Message_HMACauth {
	if m != nil {
		return m.HmacAuth
	}
	return nil
}

func (m *Message) GetPinAuth() *Message_PINauth {
	if m != nil {
		return m.PinAuth
	}
	return nil
}

func (m *Message) GetCommandBytes() []byte {
	if m != nil {
		return m.CommandBytes
	}
	return nil
}

// This is for normal message to the device
// and for responses. These are allowed once the
// device is unlocked. The HMAC provides for
// authenticity, Integrity and to enforce roles.
type Message_HMACauth struct {
	// The "identity" identifies the requester and the key and algorithm to
	// be used for hmac.
	Identity         *int64 `protobuf:"varint,1,opt,name=identity" json:"identity,omitempty"`
	Hmac             []byte `protobuf:"bytes,2,opt,name=hmac" json:"hmac,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Message_HMACauth) Reset()                    { *m = Message_HMACauth{} }
func (m *Message_HMACauth) String() string            { return proto.CompactTextString(m) }
func (*Message_HMACauth) ProtoMessage()               {}
func (*Message_HMACauth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *Message_HMACauth) GetIdentity() int64 {
	if m != nil && m.Identity != nil {
		return *m.Identity
	}
	return 0
}

func (m *Message_HMACauth) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

// Pin based authentication for Pin operations.
type Message_PINauth struct {
	// The pin necessary to make the operations valid
	Pin              []byte `protobuf:"bytes,1,opt,name=pin" json:"pin,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Message_PINauth) Reset()                    { *m = Message_PINauth{} }
func (m *Message_PINauth) String() string            { return proto.CompactTextString(m) }
func (*Message_PINauth) ProtoMessage()               {}
func (*Message_PINauth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

func (m *Message_PINauth) GetPin() []byte {
	if m != nil {
		return m.Pin
	}
	return nil
}

type Command struct {
	// message header
	Header *Command_Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// message body
	Body *Command_Body `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
	// operation status
	Status           *Command_Status `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Command) GetHeader() *Command_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Command) GetBody() *Command_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Command) GetStatus() *Command_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// message header
type Command_Header struct {
	// "cluster" is the  number of the cluster definition. If this is incompatible,
	// the request is rejected. If it is missing, it is assumed to be 0. (0 allows systems not
	// using cluster versioning to ignore this field in the header and in the setup.)
	ClusterVersion *int64 `protobuf:"varint,1,opt,name=clusterVersion" json:"clusterVersion,omitempty"`
	// A unique number for this connection between the source and target. On the first request
	// to the device, this should be the time of day in seconds since 1970. The device can change this
	// number and the client must continue to use the new number and the number must remain
	// constant during the session. (See security document).
	ConnectionID *int64 `protobuf:"varint,3,opt,name=connectionID" json:"connectionID,omitempty"`
	// the sequence of this request in this TCP connection. As long as this value is getting larger we have
	// strong ordering and replay prevention within a session. This combined with the time and connectionID
	// provides strong ordering between sessions. (See security document).
	Sequence *int64 `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
	// co-related sequence
	AckSequence *int64 `protobuf:"varint,6,opt,name=ackSequence" json:"ackSequence,omitempty"`
	// operation code - put/get/delete/GetLog, etc.
	MessageType *Command_MessageType `protobuf:"varint,7,opt,name=messageType,enum=com.seagate.kinetic.proto.Command_MessageType" json:"messageType,omitempty"`
	// Request timeout (in ms). This is the amount of time that this request should take. If this timeout
	// is triggered, there are three possible results that can be returned.
	//   - SERVICE_BUSY meaning that the request was still on the queue waiting to be executed
	//   - EXPIRED meaning that a long running operation was stopped because the time expired.
	//   - DATA_ERROR meaning that the request was in process, but that the error recovery was not
	//          complete at the time that the time expired
	Timeout *int64 `protobuf:"varint,9,opt,name=timeout" json:"timeout,omitempty"`
	// If true, requests will not attempt multi revolution recoveries even if the timeout has not occurred.
	// In this case the result will be DATA_ERROR. To have the device exhaust all possible error recovery, leave
	// this field off or set to false, and make sure that the timeout is set to be longer than any possible queue
	// time and error recovery time. On a disk device, the maximum error recovery time could be seconds.
	// Once all possible data recovery operations are complete and have not succeeded, PERM_DATA_ERROR will be
	// returned.
	EarlyExit *bool `protobuf:"varint,10,opt,name=earlyExit" json:"earlyExit,omitempty"`
	// Priority is a simple integer that determines the priority of this
	// request. All activity at a higher priority will execute before that
	// of lower priority traffic. A higher number is higher priority.
	Priority *Command_Priority `protobuf:"varint,12,opt,name=priority,enum=com.seagate.kinetic.proto.Command_Priority" json:"priority,omitempty"`
	// A hint of how long a job should run before yielding. Specified in
	// miliseconds. A value of 0 indicates that the operation can perform one
	// sub operation and then check to see if there are other sub higher
	// priority operations. An example of a sub-operation might be a single put
	// in a P2P operation, etc.
	TimeQuanta *int64 `protobuf:"varint,13,opt,name=TimeQuanta" json:"TimeQuanta,omitempty"`
	// batch id to be included in each command of a batch operation
	// this id is generated by client library and must be unique
	// within the same connection.
	BatchID          *uint32 `protobuf:"varint,14,opt,name=batchID" json:"batchID,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Command_Header) Reset()                    { *m = Command_Header{} }
func (m *Command_Header) String() string            { return proto.CompactTextString(m) }
func (*Command_Header) ProtoMessage()               {}
func (*Command_Header) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *Command_Header) GetClusterVersion() int64 {
	if m != nil && m.ClusterVersion != nil {
		return *m.ClusterVersion
	}
	return 0
}

func (m *Command_Header) GetConnectionID() int64 {
	if m != nil && m.ConnectionID != nil {
		return *m.ConnectionID
	}
	return 0
}

func (m *Command_Header) GetSequence() int64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *Command_Header) GetAckSequence() int64 {
	if m != nil && m.AckSequence != nil {
		return *m.AckSequence
	}
	return 0
}

func (m *Command_Header) GetMessageType() Command_MessageType {
	if m != nil && m.MessageType != nil {
		return *m.MessageType
	}
	return Command_INVALID_MESSAGE_TYPE
}

func (m *Command_Header) GetTimeout() int64 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *Command_Header) GetEarlyExit() bool {
	if m != nil && m.EarlyExit != nil {
		return *m.EarlyExit
	}
	return false
}

func (m *Command_Header) GetPriority() Command_Priority {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return Command_NORMAL
}

func (m *Command_Header) GetTimeQuanta() int64 {
	if m != nil && m.TimeQuanta != nil {
		return *m.TimeQuanta
	}
	return 0
}

func (m *Command_Header) GetBatchID() uint32 {
	if m != nil && m.BatchID != nil {
		return *m.BatchID
	}
	return 0
}

// message body
type Command_Body struct {
	// key/value op
	KeyValue *Command_KeyValue `protobuf:"bytes,1,opt,name=keyValue" json:"keyValue,omitempty"`
	// range operation
	Range *Command_Range `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	// set up operation
	Setup *Command_Setup `protobuf:"bytes,3,opt,name=setup" json:"setup,omitempty"`
	// Peer to Peer operations.
	P2POperation *Command_P2POperation `protobuf:"bytes,4,opt,name=p2pOperation" json:"p2pOperation,omitempty"`
	// GetLog
	GetLog *Command_GetLog `protobuf:"bytes,6,opt,name=getLog" json:"getLog,omitempty"`
	// set up security
	Security *Command_Security `protobuf:"bytes,7,opt,name=security" json:"security,omitempty"`
	// Perform Pin-based operations
	PinOp *Command_PinOperation `protobuf:"bytes,8,opt,name=pinOp" json:"pinOp,omitempty"`
	// batch operation
	// This is included in the END_BATCH and END_BATCH_RESPONSE.
	Batch            *Command_Batch `protobuf:"bytes,9,opt,name=batch" json:"batch,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Command_Body) Reset()                    { *m = Command_Body{} }
func (m *Command_Body) String() string            { return proto.CompactTextString(m) }
func (*Command_Body) ProtoMessage()               {}
func (*Command_Body) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

func (m *Command_Body) GetKeyValue() *Command_KeyValue {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

func (m *Command_Body) GetRange() *Command_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Command_Body) GetSetup() *Command_Setup {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *Command_Body) GetP2POperation() *Command_P2POperation {
	if m != nil {
		return m.P2POperation
	}
	return nil
}

func (m *Command_Body) GetGetLog() *Command_GetLog {
	if m != nil {
		return m.GetLog
	}
	return nil
}

func (m *Command_Body) GetSecurity() *Command_Security {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *Command_Body) GetPinOp() *Command_PinOperation {
	if m != nil {
		return m.PinOp
	}
	return nil
}

func (m *Command_Body) GetBatch() *Command_Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

// This is included in the END_BATCH and END_BATCH_RESPONSE.
type Command_Batch struct {
	// set by the client library in END_BATCH request message.
	// the total number of operations in the batch
	Count *int32 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// set by the drive in END_BATCH_RESPONSE message.
	// If a batch is committed successfully, all sequence Ids of those
	// commands (PUT/DELETE) performed in the batch are
	// added in the END_BATCH_RESPONSE message.
	Sequence []int64 `protobuf:"varint,2,rep,packed,name=sequence" json:"sequence,omitempty"`
	// This field is set by the drive if a batch commit failed.
	// The first failed operation sequence in the batch is set as value.
	FailedSequence   *int64 `protobuf:"varint,3,opt,name=failedSequence" json:"failedSequence,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_Batch) Reset()                    { *m = Command_Batch{} }
func (m *Command_Batch) String() string            { return proto.CompactTextString(m) }
func (*Command_Batch) ProtoMessage()               {}
func (*Command_Batch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 2} }

func (m *Command_Batch) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *Command_Batch) GetSequence() []int64 {
	if m != nil {
		return m.Sequence
	}
	return nil
}

func (m *Command_Batch) GetFailedSequence() int64 {
	if m != nil && m.FailedSequence != nil {
		return *m.FailedSequence
	}
	return 0
}

// operation status
type Command_Status struct {
	// status code
	Code *Command_Status_StatusCode `protobuf:"varint,1,opt,name=code,enum=com.seagate.kinetic.proto.Command_Status_StatusCode" json:"code,omitempty"`
	// status message
	StatusMessage *string `protobuf:"bytes,2,opt,name=statusMessage" json:"statusMessage,omitempty"`
	// optional information comes with status
	DetailedMessage  []byte `protobuf:"bytes,3,opt,name=detailedMessage" json:"detailedMessage,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_Status) Reset()                    { *m = Command_Status{} }
func (m *Command_Status) String() string            { return proto.CompactTextString(m) }
func (*Command_Status) ProtoMessage()               {}
func (*Command_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 3} }

func (m *Command_Status) GetCode() Command_Status_StatusCode {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return Command_Status_INVALID_STATUS_CODE
}

func (m *Command_Status) GetStatusMessage() string {
	if m != nil && m.StatusMessage != nil {
		return *m.StatusMessage
	}
	return ""
}

func (m *Command_Status) GetDetailedMessage() []byte {
	if m != nil {
		return m.DetailedMessage
	}
	return nil
}

// key/value entry operation
type Command_KeyValue struct {
	// On a put or delete, this is the next version that the data will be. The version field is opaque to the
	// target. (See Atomic operations document)
	NewVersion []byte `protobuf:"bytes,2,opt,name=newVersion" json:"newVersion,omitempty"`
	// On a put or delete, this forces the write to ignore the existing version of existing data (if it exists).
	Force *bool `protobuf:"varint,8,opt,name=force" json:"force,omitempty"`
	// entry key
	Key []byte `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	// entry version in store
	DbVersion []byte `protobuf:"bytes,4,opt,name=dbVersion" json:"dbVersion,omitempty"`
	// this is the integrity value of the data. This may or may not be in the clear, depending on the algorithm
	// used.
	Tag []byte `protobuf:"bytes,5,opt,name=tag" json:"tag,omitempty"`
	// The following is for the protection of the data. If the data is protected with a hash or CRC, then
	// the algorithm will be negative. If the data protection algorithm is not a standard unkeyed algorithm
	// then  a positive number is used and the device has no idea what the key is. See the discussion of
	// encrypted key/value store.(See security document).
	Algorithm *Command_Algorithm `protobuf:"varint,6,opt,name=algorithm,enum=com.seagate.kinetic.proto.Command_Algorithm" json:"algorithm,omitempty"`
	// for read operations, this will get all the information about the value except for the
	// value itself. This is valuable for getting the integrity field or the version without also
	// having to get the data. If this field is not present, it is as if it is false. For
	// write or delete operations, if this is set, the command is rejected.
	MetadataOnly *bool `protobuf:"varint,7,opt,name=metadataOnly" json:"metadataOnly,omitempty"`
	// Synchronization allows the puts and deletes to determine if they are to be
	// WRITETHROUGH: This request is made persistent before returning. This does not effect any other pending operations.
	// WRITEBACK: They can be made persistent when the device chooses, or when a subsequent FLUSH is give to the device.
	// FLUSH: All pending information that has not been written is pushed to the disk and the command that
	//    specifies FLUSH is written last and then returned. All WRITEBACK writes that have received ending
	//    status will be guaranteed to be written before the FLUSH operation is returned completed.
	Synchronization  *Command_Synchronization `protobuf:"varint,9,opt,name=synchronization,enum=com.seagate.kinetic.proto.Command_Synchronization" json:"synchronization,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *Command_KeyValue) Reset()                    { *m = Command_KeyValue{} }
func (m *Command_KeyValue) String() string            { return proto.CompactTextString(m) }
func (*Command_KeyValue) ProtoMessage()               {}
func (*Command_KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 4} }

func (m *Command_KeyValue) GetNewVersion() []byte {
	if m != nil {
		return m.NewVersion
	}
	return nil
}

func (m *Command_KeyValue) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *Command_KeyValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_KeyValue) GetDbVersion() []byte {
	if m != nil {
		return m.DbVersion
	}
	return nil
}

func (m *Command_KeyValue) GetTag() []byte {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *Command_KeyValue) GetAlgorithm() Command_Algorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return Command_INVALID_ALGORITHM
}

func (m *Command_KeyValue) GetMetadataOnly() bool {
	if m != nil && m.MetadataOnly != nil {
		return *m.MetadataOnly
	}
	return false
}

func (m *Command_KeyValue) GetSynchronization() Command_Synchronization {
	if m != nil && m.Synchronization != nil {
		return *m.Synchronization
	}
	return Command_INVALID_SYNCHRONIZATION
}

// key range op
type Command_Range struct {
	StartKey          []byte `protobuf:"bytes,1,opt,name=startKey" json:"startKey,omitempty"`
	EndKey            []byte `protobuf:"bytes,2,opt,name=endKey" json:"endKey,omitempty"`
	StartKeyInclusive *bool  `protobuf:"varint,3,opt,name=startKeyInclusive" json:"startKeyInclusive,omitempty"`
	EndKeyInclusive   *bool  `protobuf:"varint,4,opt,name=endKeyInclusive" json:"endKeyInclusive,omitempty"`
	// The maximum number of keys returned
	MaxReturned *int32 `protobuf:"varint,5,opt,name=maxReturned" json:"maxReturned,omitempty"`
	// The keys are searched for and returned in a reverse order. For instance
	// if the search is startKey="j", endKey="k", maxReturned=2,
	// reverse=true and the keys "k0", "k1", "k2" exist
	// the system will return "k2" and "k1" in that order.
	Reverse *bool `protobuf:"varint,6,opt,name=reverse" json:"reverse,omitempty"`
	// get range response .
	Keys             [][]byte `protobuf:"bytes,8,rep,name=keys" json:"keys,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Command_Range) Reset()                    { *m = Command_Range{} }
func (m *Command_Range) String() string            { return proto.CompactTextString(m) }
func (*Command_Range) ProtoMessage()               {}
func (*Command_Range) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 5} }

func (m *Command_Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Command_Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Command_Range) GetStartKeyInclusive() bool {
	if m != nil && m.StartKeyInclusive != nil {
		return *m.StartKeyInclusive
	}
	return false
}

func (m *Command_Range) GetEndKeyInclusive() bool {
	if m != nil && m.EndKeyInclusive != nil {
		return *m.EndKeyInclusive
	}
	return false
}

func (m *Command_Range) GetMaxReturned() int32 {
	if m != nil && m.MaxReturned != nil {
		return *m.MaxReturned
	}
	return 0
}

func (m *Command_Range) GetReverse() bool {
	if m != nil && m.Reverse != nil {
		return *m.Reverse
	}
	return false
}

func (m *Command_Range) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// if any or all of these are fields are included, they are set.
// These are persistent options that are retained across power fail and
// erased on either PIN erase or PIN secure erase.
type Command_Setup struct {
	// The cluster version to be checked. The default if never set is 0.
	// If this is missing, it is assumed to be unchanged;
	// This is persistent between boots of the device.
	NewClusterVersion *int64 `protobuf:"varint,1,opt,name=newClusterVersion" json:"newClusterVersion,omitempty"`
	// indicates the presence of a firmware load in the data portion of this
	// message. The firmware is itself protected on its own for integrity,
	// authenticity, etc.
	FirmwareDownload *bool  `protobuf:"varint,5,opt,name=firmwareDownload" json:"firmwareDownload,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_Setup) Reset()                    { *m = Command_Setup{} }
func (m *Command_Setup) String() string            { return proto.CompactTextString(m) }
func (*Command_Setup) ProtoMessage()               {}
func (*Command_Setup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 6} }

func (m *Command_Setup) GetNewClusterVersion() int64 {
	if m != nil && m.NewClusterVersion != nil {
		return *m.NewClusterVersion
	}
	return 0
}

func (m *Command_Setup) GetFirmwareDownload() bool {
	if m != nil && m.FirmwareDownload != nil {
		return *m.FirmwareDownload
	}
	return false
}

// P2P operations allow devices to be able to send keys to other devices.
// this is either a standalone command or added to a put command.
type Command_P2POperation struct {
	// Describe the target machine
	Peer *Command_P2POperation_Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	// List of operations to be performed.
	Operation []*Command_P2POperation_Operation `protobuf:"bytes,2,rep,name=operation" json:"operation,omitempty"`
	// Indicates whether all operations have Status SUCCESS
	// When false, clients should traverse Operation status codes to discover
	// error cases.
	// When true, no further error checking should be required.
	AllChildOperationsSucceeded *bool  `protobuf:"varint,3,opt,name=allChildOperationsSucceeded" json:"allChildOperationsSucceeded,omitempty"`
	XXX_unrecognized            []byte `json:"-"`
}

func (m *Command_P2POperation) Reset()                    { *m = Command_P2POperation{} }
func (m *Command_P2POperation) String() string            { return proto.CompactTextString(m) }
func (*Command_P2POperation) ProtoMessage()               {}
func (*Command_P2POperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 7} }

func (m *Command_P2POperation) GetPeer() *Command_P2POperation_Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Command_P2POperation) GetOperation() []*Command_P2POperation_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *Command_P2POperation) GetAllChildOperationsSucceeded() bool {
	if m != nil && m.AllChildOperationsSucceeded != nil {
		return *m.AllChildOperationsSucceeded
	}
	return false
}

type Command_P2POperation_Operation struct {
	// the key of the entry to move
	Key []byte `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	// the expected version number in the other machine
	// the version number will be the version in the stored entry.
	Version []byte `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// to have the moved key have a different final key used.
	NewKey []byte `protobuf:"bytes,5,opt,name=newKey" json:"newKey,omitempty"`
	// force the write ignoring the current key version.
	Force *bool `protobuf:"varint,6,opt,name=force" json:"force,omitempty"`
	// returned status
	Status *Command_Status `protobuf:"bytes,7,opt,name=status" json:"status,omitempty"`
	// an operation to add to this put operation. THis allows the
	// formation of a pipeline client -> A ->B ->C with the status for all returning
	// back to the client.
	P2Pop            *Command_P2POperation `protobuf:"bytes,8,opt,name=p2pop" json:"p2pop,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Command_P2POperation_Operation) Reset()         { *m = Command_P2POperation_Operation{} }
func (m *Command_P2POperation_Operation) String() string { return proto.CompactTextString(m) }
func (*Command_P2POperation_Operation) ProtoMessage()    {}
func (*Command_P2POperation_Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 7, 0}
}

func (m *Command_P2POperation_Operation) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetVersion() []byte {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetNewKey() []byte {
	if m != nil {
		return m.NewKey
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *Command_P2POperation_Operation) GetStatus() *Command_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetP2Pop() *Command_P2POperation {
	if m != nil {
		return m.P2Pop
	}
	return nil
}

type Command_P2POperation_Peer struct {
	Hostname         *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Port             *int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	Tls              *bool   `protobuf:"varint,3,opt,name=tls" json:"tls,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Command_P2POperation_Peer) Reset()                    { *m = Command_P2POperation_Peer{} }
func (m *Command_P2POperation_Peer) String() string            { return proto.CompactTextString(m) }
func (*Command_P2POperation_Peer) ProtoMessage()               {}
func (*Command_P2POperation_Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 7, 1} }

func (m *Command_P2POperation_Peer) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Command_P2POperation_Peer) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *Command_P2POperation_Peer) GetTls() bool {
	if m != nil && m.Tls != nil {
		return *m.Tls
	}
	return false
}

// get log
type Command_GetLog struct {
	Types            []Command_GetLog_Type         `protobuf:"varint,1,rep,name=types,enum=com.seagate.kinetic.proto.Command_GetLog_Type" json:"types,omitempty"`
	Utilizations     []*Command_GetLog_Utilization `protobuf:"bytes,2,rep,name=utilizations" json:"utilizations,omitempty"`
	Temperatures     []*Command_GetLog_Temperature `protobuf:"bytes,3,rep,name=temperatures" json:"temperatures,omitempty"`
	Capacity         *Command_GetLog_Capacity      `protobuf:"bytes,4,opt,name=capacity" json:"capacity,omitempty"`
	Configuration    *Command_GetLog_Configuration `protobuf:"bytes,5,opt,name=configuration" json:"configuration,omitempty"`
	Statistics       []*Command_GetLog_Statistics  `protobuf:"bytes,6,rep,name=statistics" json:"statistics,omitempty"`
	Messages         []byte                        `protobuf:"bytes,7,opt,name=messages" json:"messages,omitempty"`
	Limits           *Command_GetLog_Limits        `protobuf:"bytes,8,opt,name=limits" json:"limits,omitempty"`
	Device           *Command_GetLog_Device        `protobuf:"bytes,9,opt,name=device" json:"device,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *Command_GetLog) Reset()                    { *m = Command_GetLog{} }
func (m *Command_GetLog) String() string            { return proto.CompactTextString(m) }
func (*Command_GetLog) ProtoMessage()               {}
func (*Command_GetLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8} }

func (m *Command_GetLog) GetTypes() []Command_GetLog_Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Command_GetLog) GetUtilizations() []*Command_GetLog_Utilization {
	if m != nil {
		return m.Utilizations
	}
	return nil
}

func (m *Command_GetLog) GetTemperatures() []*Command_GetLog_Temperature {
	if m != nil {
		return m.Temperatures
	}
	return nil
}

func (m *Command_GetLog) GetCapacity() *Command_GetLog_Capacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *Command_GetLog) GetConfiguration() *Command_GetLog_Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *Command_GetLog) GetStatistics() []*Command_GetLog_Statistics {
	if m != nil {
		return m.Statistics
	}
	return nil
}

func (m *Command_GetLog) GetMessages() []byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *Command_GetLog) GetLimits() *Command_GetLog_Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Command_GetLog) GetDevice() *Command_GetLog_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

type Command_GetLog_Utilization struct {
	// The name of the utilization being reported. These names can be standard and proprietary. The
	// standard names are "HDA", "EN0" and "EN1". If there are more items that are
	// being reported, such as processor utilization, can have a descriptive name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A number between 0.00 and 1.00. The resolution of this number is up to the
	// device. 1 means 100% utilized.
	Value            *float32 `protobuf:"fixed32,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Command_GetLog_Utilization) Reset()         { *m = Command_GetLog_Utilization{} }
func (m *Command_GetLog_Utilization) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Utilization) ProtoMessage()    {}
func (*Command_GetLog_Utilization) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 8, 0}
}

func (m *Command_GetLog_Utilization) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Utilization) GetValue() float32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type Command_GetLog_Temperature struct {
	// The name of the temperature being reported. These names can be standard and proprietary. The
	// standard name is "HDA". If there are more items that are
	// being reported, such as processor temperature, can have a descriptive name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The current temperature in degrees c
	Current          *float32 `protobuf:"fixed32,2,opt,name=current" json:"current,omitempty"`
	Minimum          *float32 `protobuf:"fixed32,3,opt,name=minimum" json:"minimum,omitempty"`
	Maximum          *float32 `protobuf:"fixed32,4,opt,name=maximum" json:"maximum,omitempty"`
	Target           *float32 `protobuf:"fixed32,5,opt,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Command_GetLog_Temperature) Reset()         { *m = Command_GetLog_Temperature{} }
func (m *Command_GetLog_Temperature) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Temperature) ProtoMessage()    {}
func (*Command_GetLog_Temperature) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 8, 1}
}

func (m *Command_GetLog_Temperature) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Temperature) GetCurrent() float32 {
	if m != nil && m.Current != nil {
		return *m.Current
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetMinimum() float32 {
	if m != nil && m.Minimum != nil {
		return *m.Minimum
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetMaximum() float32 {
	if m != nil && m.Maximum != nil {
		return *m.Maximum
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetTarget() float32 {
	if m != nil && m.Target != nil {
		return *m.Target
	}
	return 0
}

// These capacities are in bytes.
type Command_GetLog_Capacity struct {
	// 1-3 are reserved
	NominalCapacityInBytes *uint64  `protobuf:"varint,4,opt,name=nominalCapacityInBytes" json:"nominalCapacityInBytes,omitempty"`
	PortionFull            *float32 `protobuf:"fixed32,5,opt,name=portionFull" json:"portionFull,omitempty"`
	XXX_unrecognized       []byte   `json:"-"`
}

func (m *Command_GetLog_Capacity) Reset()                    { *m = Command_GetLog_Capacity{} }
func (m *Command_GetLog_Capacity) String() string            { return proto.CompactTextString(m) }
func (*Command_GetLog_Capacity) ProtoMessage()               {}
func (*Command_GetLog_Capacity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8, 2} }

func (m *Command_GetLog_Capacity) GetNominalCapacityInBytes() uint64 {
	if m != nil && m.NominalCapacityInBytes != nil {
		return *m.NominalCapacityInBytes
	}
	return 0
}

func (m *Command_GetLog_Capacity) GetPortionFull() float32 {
	if m != nil && m.PortionFull != nil {
		return *m.PortionFull
	}
	return 0
}

type Command_GetLog_Configuration struct {
	// name of the vendor. Should be "Seagate"
	Vendor *string `protobuf:"bytes,5,opt,name=vendor" json:"vendor,omitempty"`
	// The model of the device.
	// "Simulator" for the simulator.
	Model *string `protobuf:"bytes,6,opt,name=model" json:"model,omitempty"`
	// Device Serial number (SN)
	SerialNumber []byte `protobuf:"bytes,7,opt,name=serialNumber" json:"serialNumber,omitempty"`
	// Device world wide name (WWN)
	WorldWideName []byte `protobuf:"bytes,14,opt,name=worldWideName" json:"worldWideName,omitempty"`
	// This is the vendor specific version of the software on the device in dot notation
	// if this is not set or ends with "x" this is test code.
	Version         *string `protobuf:"bytes,8,opt,name=version" json:"version,omitempty"`
	CompilationDate *string `protobuf:"bytes,12,opt,name=compilationDate" json:"compilationDate,omitempty"`
	SourceHash      *string `protobuf:"bytes,13,opt,name=sourceHash" json:"sourceHash,omitempty"`
	// This is the version of the protocol (.proto file) that the device uses.
	// This is not the highest or lowest version that is supported, just
	// the version that was compiled.
	ProtocolVersion         *string `protobuf:"bytes,15,opt,name=protocolVersion" json:"protocolVersion,omitempty"`
	ProtocolCompilationDate *string `protobuf:"bytes,16,opt,name=protocolCompilationDate" json:"protocolCompilationDate,omitempty"`
	ProtocolSourceHash      *string `protobuf:"bytes,17,opt,name=protocolSourceHash" json:"protocolSourceHash,omitempty"`
	// the interfaces for this device. one per interface.
	Interface []*Command_GetLog_Configuration_Interface `protobuf:"bytes,9,rep,name=interface" json:"interface,omitempty"`
	// these are the port numbers for the software
	Port             *int32 `protobuf:"varint,10,opt,name=port" json:"port,omitempty"`
	TlsPort          *int32 `protobuf:"varint,11,opt,name=tlsPort" json:"tlsPort,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_GetLog_Configuration) Reset()         { *m = Command_GetLog_Configuration{} }
func (m *Command_GetLog_Configuration) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Configuration) ProtoMessage()    {}
func (*Command_GetLog_Configuration) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 8, 3}
}

func (m *Command_GetLog_Configuration) GetVendor() string {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetSerialNumber() []byte {
	if m != nil {
		return m.SerialNumber
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetWorldWideName() []byte {
	if m != nil {
		return m.WorldWideName
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetCompilationDate() string {
	if m != nil && m.CompilationDate != nil {
		return *m.CompilationDate
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetSourceHash() string {
	if m != nil && m.SourceHash != nil {
		return *m.SourceHash
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolVersion() string {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolCompilationDate() string {
	if m != nil && m.ProtocolCompilationDate != nil {
		return *m.ProtocolCompilationDate
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolSourceHash() string {
	if m != nil && m.ProtocolSourceHash != nil {
		return *m.ProtocolSourceHash
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetInterface() []*Command_GetLog_Configuration_Interface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *Command_GetLog_Configuration) GetTlsPort() int32 {
	if m != nil && m.TlsPort != nil {
		return *m.TlsPort
	}
	return 0
}

// 18, 19 are reserved.
type Command_GetLog_Configuration_Interface struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	MAC              []byte  `protobuf:"bytes,2,opt,name=MAC" json:"MAC,omitempty"`
	Ipv4Address      []byte  `protobuf:"bytes,3,opt,name=ipv4Address" json:"ipv4Address,omitempty"`
	Ipv6Address      []byte  `protobuf:"bytes,4,opt,name=ipv6Address" json:"ipv6Address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Command_GetLog_Configuration_Interface) Reset() {
	*m = Command_GetLog_Configuration_Interface{}
}
func (m *Command_GetLog_Configuration_Interface) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Configuration_Interface) ProtoMessage()    {}
func (*Command_GetLog_Configuration_Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 8, 3, 0}
}

func (m *Command_GetLog_Configuration_Interface) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Configuration_Interface) GetMAC() []byte {
	if m != nil {
		return m.MAC
	}
	return nil
}

func (m *Command_GetLog_Configuration_Interface) GetIpv4Address() []byte {
	if m != nil {
		return m.Ipv4Address
	}
	return nil
}

func (m *Command_GetLog_Configuration_Interface) GetIpv6Address() []byte {
	if m != nil {
		return m.Ipv6Address
	}
	return nil
}

// These numbers start at 0 when the device starts up and never wraps or resets.
type Command_GetLog_Statistics struct {
	MessageType *Command_MessageType `protobuf:"varint,1,opt,name=messageType,enum=com.seagate.kinetic.proto.Command_MessageType" json:"messageType,omitempty"`
	// 2 and 3 are reserved, do not use
	Count *uint64 `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	// This is the sum of the data that is in the data portion. This does not include t
	// the command description. For P2P operations, this is the amount of data moved between
	// devices
	Bytes            *uint64 `protobuf:"varint,5,opt,name=bytes" json:"bytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Command_GetLog_Statistics) Reset()                    { *m = Command_GetLog_Statistics{} }
func (m *Command_GetLog_Statistics) String() string            { return proto.CompactTextString(m) }
func (*Command_GetLog_Statistics) ProtoMessage()               {}
func (*Command_GetLog_Statistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8, 4} }

func (m *Command_GetLog_Statistics) GetMessageType() Command_MessageType {
	if m != nil && m.MessageType != nil {
		return *m.MessageType
	}
	return Command_INVALID_MESSAGE_TYPE
}

func (m *Command_GetLog_Statistics) GetCount() uint64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *Command_GetLog_Statistics) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

type Command_GetLog_Limits struct {
	MaxKeySize                  *uint32 `protobuf:"varint,1,opt,name=maxKeySize" json:"maxKeySize,omitempty"`
	MaxValueSize                *uint32 `protobuf:"varint,2,opt,name=maxValueSize" json:"maxValueSize,omitempty"`
	MaxVersionSize              *uint32 `protobuf:"varint,3,opt,name=maxVersionSize" json:"maxVersionSize,omitempty"`
	MaxTagSize                  *uint32 `protobuf:"varint,4,opt,name=maxTagSize" json:"maxTagSize,omitempty"`
	MaxConnections              *uint32 `protobuf:"varint,5,opt,name=maxConnections" json:"maxConnections,omitempty"`
	MaxOutstandingReadRequests  *uint32 `protobuf:"varint,6,opt,name=maxOutstandingReadRequests" json:"maxOutstandingReadRequests,omitempty"`
	MaxOutstandingWriteRequests *uint32 `protobuf:"varint,7,opt,name=maxOutstandingWriteRequests" json:"maxOutstandingWriteRequests,omitempty"`
	MaxMessageSize              *uint32 `protobuf:"varint,8,opt,name=maxMessageSize" json:"maxMessageSize,omitempty"`
	MaxKeyRangeCount            *uint32 `protobuf:"varint,9,opt,name=maxKeyRangeCount" json:"maxKeyRangeCount,omitempty"`
	MaxIdentityCount            *uint32 `protobuf:"varint,10,opt,name=maxIdentityCount" json:"maxIdentityCount,omitempty"`
	MaxPinSize                  *uint32 `protobuf:"varint,11,opt,name=maxPinSize" json:"maxPinSize,omitempty"`
	MaxOperationCountPerBatch   *uint32 `protobuf:"varint,12,opt,name=maxOperationCountPerBatch" json:"maxOperationCountPerBatch,omitempty"`
	MaxBatchCountPerDevice      *uint32 `protobuf:"varint,13,opt,name=maxBatchCountPerDevice" json:"maxBatchCountPerDevice,omitempty"`
	XXX_unrecognized            []byte  `json:"-"`
}

func (m *Command_GetLog_Limits) Reset()                    { *m = Command_GetLog_Limits{} }
func (m *Command_GetLog_Limits) String() string            { return proto.CompactTextString(m) }
func (*Command_GetLog_Limits) ProtoMessage()               {}
func (*Command_GetLog_Limits) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8, 5} }

func (m *Command_GetLog_Limits) GetMaxKeySize() uint32 {
	if m != nil && m.MaxKeySize != nil {
		return *m.MaxKeySize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxValueSize() uint32 {
	if m != nil && m.MaxValueSize != nil {
		return *m.MaxValueSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxVersionSize() uint32 {
	if m != nil && m.MaxVersionSize != nil {
		return *m.MaxVersionSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxTagSize() uint32 {
	if m != nil && m.MaxTagSize != nil {
		return *m.MaxTagSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxConnections() uint32 {
	if m != nil && m.MaxConnections != nil {
		return *m.MaxConnections
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOutstandingReadRequests() uint32 {
	if m != nil && m.MaxOutstandingReadRequests != nil {
		return *m.MaxOutstandingReadRequests
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOutstandingWriteRequests() uint32 {
	if m != nil && m.MaxOutstandingWriteRequests != nil {
		return *m.MaxOutstandingWriteRequests
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxMessageSize() uint32 {
	if m != nil && m.MaxMessageSize != nil {
		return *m.MaxMessageSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxKeyRangeCount() uint32 {
	if m != nil && m.MaxKeyRangeCount != nil {
		return *m.MaxKeyRangeCount
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxIdentityCount() uint32 {
	if m != nil && m.MaxIdentityCount != nil {
		return *m.MaxIdentityCount
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxPinSize() uint32 {
	if m != nil && m.MaxPinSize != nil {
		return *m.MaxPinSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOperationCountPerBatch() uint32 {
	if m != nil && m.MaxOperationCountPerBatch != nil {
		return *m.MaxOperationCountPerBatch
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxBatchCountPerDevice() uint32 {
	if m != nil && m.MaxBatchCountPerDevice != nil {
		return *m.MaxBatchCountPerDevice
	}
	return 0
}

// The Device GetLog message is to ask the device to send back the
// log of a certain name in the value field. The limit of each
// log is 1m byte.
//
// Proprietary names should be prefaced by the vendor name so that name
// collisions do not happen in the future. An example could be names that
// start with com.WD would be for Western Digital devices.
//
// If the name is not found, the get log returns NOT_FOUND.
//
// There can be only one Device in the list of logs that can be retrieved.!
type Command_GetLog_Device struct {
	Name             []byte `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_GetLog_Device) Reset()                    { *m = Command_GetLog_Device{} }
func (m *Command_GetLog_Device) String() string            { return proto.CompactTextString(m) }
func (*Command_GetLog_Device) ProtoMessage()               {}
func (*Command_GetLog_Device) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 8, 6} }

func (m *Command_GetLog_Device) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// These are persistent options that are retained across power fail and
// erased on either PIN erase or PIN secure erase.
type Command_Security struct {
	Acl []*Command_Security_ACL `protobuf:"bytes,2,rep,name=acl" json:"acl,omitempty"`
	// Set the lock and erase pins.
	OldLockPIN       []byte `protobuf:"bytes,3,opt,name=oldLockPIN" json:"oldLockPIN,omitempty"`
	NewLockPIN       []byte `protobuf:"bytes,4,opt,name=newLockPIN" json:"newLockPIN,omitempty"`
	OldErasePIN      []byte `protobuf:"bytes,5,opt,name=oldErasePIN" json:"oldErasePIN,omitempty"`
	NewErasePIN      []byte `protobuf:"bytes,6,opt,name=newErasePIN" json:"newErasePIN,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Command_Security) Reset()                    { *m = Command_Security{} }
func (m *Command_Security) String() string            { return proto.CompactTextString(m) }
func (*Command_Security) ProtoMessage()               {}
func (*Command_Security) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 9} }

func (m *Command_Security) GetAcl() []*Command_Security_ACL {
	if m != nil {
		return m.Acl
	}
	return nil
}

func (m *Command_Security) GetOldLockPIN() []byte {
	if m != nil {
		return m.OldLockPIN
	}
	return nil
}

func (m *Command_Security) GetNewLockPIN() []byte {
	if m != nil {
		return m.NewLockPIN
	}
	return nil
}

func (m *Command_Security) GetOldErasePIN() []byte {
	if m != nil {
		return m.OldErasePIN
	}
	return nil
}

func (m *Command_Security) GetNewErasePIN() []byte {
	if m != nil {
		return m.NewErasePIN
	}
	return nil
}

//
type Command_Security_ACL struct {
	Identity      *int64                              `protobuf:"varint,1,opt,name=identity" json:"identity,omitempty"`
	Key           []byte                              `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	HmacAlgorithm *Command_Security_ACL_HMACAlgorithm `protobuf:"varint,3,opt,name=hmacAlgorithm,enum=com.seagate.kinetic.proto.Command_Security_ACL_HMACAlgorithm" json:"hmacAlgorithm,omitempty"`
	// value that must be in the key for read, write, range requests. If none are specified
	// then no checking occurs. If one or more is specified, one must match or the request
	// is rejected
	Scope []*Command_Security_ACL_Scope `protobuf:"bytes,4,rep,name=scope" json:"scope,omitempty"`
	// The maxPriority is checked against the header priority and range
	// priority (if present) fields. The priority must be greater than
	// or equal to this maxPriority field.
	MaxPriority      *Command_Priority `protobuf:"varint,5,opt,name=maxPriority,enum=com.seagate.kinetic.proto.Command_Priority" json:"maxPriority,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Command_Security_ACL) Reset()                    { *m = Command_Security_ACL{} }
func (m *Command_Security_ACL) String() string            { return proto.CompactTextString(m) }
func (*Command_Security_ACL) ProtoMessage()               {}
func (*Command_Security_ACL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 9, 0} }

func (m *Command_Security_ACL) GetIdentity() int64 {
	if m != nil && m.Identity != nil {
		return *m.Identity
	}
	return 0
}

func (m *Command_Security_ACL) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_Security_ACL) GetHmacAlgorithm() Command_Security_ACL_HMACAlgorithm {
	if m != nil && m.HmacAlgorithm != nil {
		return *m.HmacAlgorithm
	}
	return Command_Security_ACL_INVALID_HMAC_ALGORITHM
}

func (m *Command_Security_ACL) GetScope() []*Command_Security_ACL_Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Command_Security_ACL) GetMaxPriority() Command_Priority {
	if m != nil && m.MaxPriority != nil {
		return *m.MaxPriority
	}
	return Command_NORMAL
}

type Command_Security_ACL_Scope struct {
	Offset           *int64                            `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Value            []byte                            `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Permission       []Command_Security_ACL_Permission `protobuf:"varint,3,rep,name=permission,enum=com.seagate.kinetic.proto.Command_Security_ACL_Permission" json:"permission,omitempty"`
	TlsRequired      *bool                             `protobuf:"varint,4,opt,name=TlsRequired" json:"TlsRequired,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *Command_Security_ACL_Scope) Reset()         { *m = Command_Security_ACL_Scope{} }
func (m *Command_Security_ACL_Scope) String() string { return proto.CompactTextString(m) }
func (*Command_Security_ACL_Scope) ProtoMessage()    {}
func (*Command_Security_ACL_Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 9, 0, 0}
}

func (m *Command_Security_ACL_Scope) GetOffset() int64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *Command_Security_ACL_Scope) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Command_Security_ACL_Scope) GetPermission() []Command_Security_ACL_Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *Command_Security_ACL_Scope) GetTlsRequired() bool {
	if m != nil && m.TlsRequired != nil {
		return *m.TlsRequired
	}
	return false
}

// Pin Operations are used for special commands that are valid when the device
// is locked or to be locked. These are unlock, lock and erase.
// This must come over the TLS connection to protect the confidentiality and
// integrity. This operations must be used with PinAuth.
type Command_PinOperation struct {
	PinOpType        *Command_PinOperation_PinOpType `protobuf:"varint,1,opt,name=pinOpType,enum=com.seagate.kinetic.proto.Command_PinOperation_PinOpType" json:"pinOpType,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *Command_PinOperation) Reset()                    { *m = Command_PinOperation{} }
func (m *Command_PinOperation) String() string            { return proto.CompactTextString(m) }
func (*Command_PinOperation) ProtoMessage()               {}
func (*Command_PinOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 10} }

func (m *Command_PinOperation) GetPinOpType() Command_PinOperation_PinOpType {
	if m != nil && m.PinOpType != nil {
		return *m.PinOpType
	}
	return Command_PinOperation_INVALID_PINOP
}

func init() {
	proto.RegisterType((*Local)(nil), "com.seagate.kinetic.proto.Local")
	proto.RegisterType((*Message)(nil), "com.seagate.kinetic.proto.Message")
	proto.RegisterType((*Message_HMACauth)(nil), "com.seagate.kinetic.proto.Message.HMACauth")
	proto.RegisterType((*Message_PINauth)(nil), "com.seagate.kinetic.proto.Message.PINauth")
	proto.RegisterType((*Command)(nil), "com.seagate.kinetic.proto.Command")
	proto.RegisterType((*Command_Header)(nil), "com.seagate.kinetic.proto.Command.Header")
	proto.RegisterType((*Command_Body)(nil), "com.seagate.kinetic.proto.Command.Body")
	proto.RegisterType((*Command_Batch)(nil), "com.seagate.kinetic.proto.Command.Batch")
	proto.RegisterType((*Command_Status)(nil), "com.seagate.kinetic.proto.Command.Status")
	proto.RegisterType((*Command_KeyValue)(nil), "com.seagate.kinetic.proto.Command.KeyValue")
	proto.RegisterType((*Command_Range)(nil), "com.seagate.kinetic.proto.Command.Range")
	proto.RegisterType((*Command_Setup)(nil), "com.seagate.kinetic.proto.Command.Setup")
	proto.RegisterType((*Command_P2POperation)(nil), "com.seagate.kinetic.proto.Command.P2POperation")
	proto.RegisterType((*Command_P2POperation_Operation)(nil), "com.seagate.kinetic.proto.Command.P2POperation.Operation")
	proto.RegisterType((*Command_P2POperation_Peer)(nil), "com.seagate.kinetic.proto.Command.P2POperation.Peer")
	proto.RegisterType((*Command_GetLog)(nil), "com.seagate.kinetic.proto.Command.GetLog")
	proto.RegisterType((*Command_GetLog_Utilization)(nil), "com.seagate.kinetic.proto.Command.GetLog.Utilization")
	proto.RegisterType((*Command_GetLog_Temperature)(nil), "com.seagate.kinetic.proto.Command.GetLog.Temperature")
	proto.RegisterType((*Command_GetLog_Capacity)(nil), "com.seagate.kinetic.proto.Command.GetLog.Capacity")
	proto.RegisterType((*Command_GetLog_Configuration)(nil), "com.seagate.kinetic.proto.Command.GetLog.Configuration")
	proto.RegisterType((*Command_GetLog_Configuration_Interface)(nil), "com.seagate.kinetic.proto.Command.GetLog.Configuration.Interface")
	proto.RegisterType((*Command_GetLog_Statistics)(nil), "com.seagate.kinetic.proto.Command.GetLog.Statistics")
	proto.RegisterType((*Command_GetLog_Limits)(nil), "com.seagate.kinetic.proto.Command.GetLog.Limits")
	proto.RegisterType((*Command_GetLog_Device)(nil), "com.seagate.kinetic.proto.Command.GetLog.Device")
	proto.RegisterType((*Command_Security)(nil), "com.seagate.kinetic.proto.Command.Security")
	proto.RegisterType((*Command_Security_ACL)(nil), "com.seagate.kinetic.proto.Command.Security.ACL")
	proto.RegisterType((*Command_Security_ACL_Scope)(nil), "com.seagate.kinetic.proto.Command.Security.ACL.Scope")
	proto.RegisterType((*Command_PinOperation)(nil), "com.seagate.kinetic.proto.Command.PinOperation")
	proto.RegisterEnum("com.seagate.kinetic.proto.Message_AuthType", Message_AuthType_name, Message_AuthType_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Synchronization", Command_Synchronization_name, Command_Synchronization_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Priority", Command_Priority_name, Command_Priority_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Algorithm", Command_Algorithm_name, Command_Algorithm_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_MessageType", Command_MessageType_name, Command_MessageType_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Status_StatusCode", Command_Status_StatusCode_name, Command_Status_StatusCode_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_GetLog_Type", Command_GetLog_Type_name, Command_GetLog_Type_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Security_ACL_HMACAlgorithm", Command_Security_ACL_HMACAlgorithm_name, Command_Security_ACL_HMACAlgorithm_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_Security_ACL_Permission", Command_Security_ACL_Permission_name, Command_Security_ACL_Permission_value)
	proto.RegisterEnum("com.seagate.kinetic.proto.Command_PinOperation_PinOpType", Command_PinOperation_PinOpType_name, Command_PinOperation_PinOpType_value)
}

func init() { proto.RegisterFile("kinetic.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2842 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x59, 0xdd, 0x72, 0xdb, 0xd6,
	0x11, 0xae, 0x44, 0x52, 0x24, 0x97, 0xa4, 0x04, 0xc3, 0xb6, 0x2c, 0x33, 0xad, 0xe3, 0x30, 0x69,
	0xe3, 0xfc, 0x94, 0x49, 0x69, 0x27, 0x99, 0xa4, 0x49, 0x53, 0x08, 0x84, 0x45, 0x8c, 0xf8, 0x17,
	0x02, 0xb4, 0xe3, 0x4c, 0xa7, 0x1c, 0x98, 0x84, 0x24, 0x8c, 0x49, 0x80, 0x05, 0x40, 0xd9, 0xca,
	0x1b, 0x74, 0x7a, 0xd5, 0x17, 0xe8, 0x03, 0xf4, 0x01, 0x7a, 0xdd, 0x99, 0xbe, 0x40, 0x1f, 0xa1,
	0xd3, 0xeb, 0xde, 0xa4, 0xbd, 0xea, 0x4c, 0xff, 0x76, 0xf7, 0xe0, 0x8f, 0x4a, 0xda, 0x52, 0xd1,
	0x85, 0x74, 0xb0, 0x67, 0x77, 0xcf, 0x39, 0xbb, 0xdf, 0xee, 0xd9, 0x3d, 0x82, 0xda, 0x33, 0xc7,
	0xb5, 0x43, 0x67, 0xda, 0x5c, 0xfa, 0x5e, 0xe8, 0xc9, 0xb7, 0xa7, 0xde, 0xa2, 0x19, 0xd8, 0xd6,
	0xa9, 0x15, 0xda, 0xcd, 0xb5, 0xa9, 0xc6, 0xeb, 0x50, 0xe8, 0x7a, 0x53, 0x6b, 0x2e, 0xdf, 0x81,
	0x3d, 0xa6, 0x4c, 0xbd, 0xf9, 0x23, 0xdb, 0x0f, 0x1c, 0xcf, 0x3d, 0xd8, 0xba, 0xbb, 0x75, 0xaf,
	0xfc, 0x51, 0xe1, 0x7e, 0xf3, 0xdd, 0xe6, 0xfb, 0x8d, 0x7f, 0x6c, 0x43, 0xb1, 0x67, 0x07, 0x81,
	0x75, 0x6a, 0xcb, 0x9f, 0x40, 0xc9, 0x5a, 0x85, 0x67, 0xe6, 0xc5, 0xd2, 0x3e, 0xc8, 0x23, 0xd3,
	0x6e, 0xeb, 0xad, 0xe6, 0x7f, 0x5d, 0xa2, 0x19, 0x49, 0x35, 0x95, 0x48, 0x84, 0xc4, 0xcf, 0x16,
	0xd6, 0x94, 0xbe, 0x0f, 0x0a, 0x28, 0x5e, 0xd9, 0x48, 0xbc, 0xd3, 0x53, 0x54, 0x5a, 0x55, 0xfe,
	0x31, 0x14, 0x97, 0x8e, 0xcb, 0xd2, 0x3b, 0x2c, 0xfd, 0xe6, 0x06, 0xd2, 0x43, 0xbd, 0xcf, 0xc2,
	0x37, 0xa0, 0x8a, 0xcc, 0x0b, 0xcb, 0x9d, 0x1d, 0x5e, 0x84, 0x76, 0x70, 0x50, 0x44, 0x0d, 0xd5,
	0xfa, 0x9b, 0x50, 0x4a, 0xd4, 0x4b, 0x50, 0x72, 0x66, 0xb6, 0x1b, 0x3a, 0xe1, 0x05, 0x5b, 0x20,
	0x27, 0x57, 0x21, 0x4f, 0xfb, 0x3d, 0xd8, 0x66, 0xde, 0x7d, 0x28, 0xc6, 0xca, 0x2a, 0x90, 0xc3,
	0x9d, 0x30, 0x57, 0xb5, 0xf1, 0x33, 0x28, 0x25, 0x27, 0xbc, 0x03, 0xd7, 0xf4, 0xfe, 0x23, 0xa5,
	0xab, 0xb7, 0x27, 0xca, 0xd8, 0xec, 0x4c, 0xcc, 0x27, 0x43, 0x4d, 0xfa, 0x77, 0xfc, 0xb3, 0x85,
	0x1a, 0x79, 0x3d, 0x9a, 0x93, 0xb6, 0x50, 0x0d, 0x69, 0xe4, 0x8f, 0x6d, 0xf9, 0x26, 0x5c, 0x1b,
	0xf7, 0x8d, 0x41, 0x57, 0x57, 0x75, 0x53, 0x6b, 0x1b, 0xa6, 0x62, 0x8e, 0x0d, 0x29, 0xd7, 0xf8,
	0x5b, 0x0b, 0x8a, 0xaa, 0xd8, 0xb8, 0xfc, 0x21, 0xec, 0x9c, 0xd9, 0xd6, 0xcc, 0xf6, 0x79, 0xe5,
	0x4a, 0xeb, 0x8d, 0xff, 0x71, 0xfe, 0x48, 0xa6, 0xd9, 0x61, 0x01, 0xf9, 0x3d, 0xc8, 0x3f, 0xf5,
	0x66, 0x17, 0x7c, 0x94, 0x4a, 0xeb, 0xf5, 0x0d, 0x04, 0x0f, 0x91, 0x9d, 0x56, 0x0c, 0x42, 0x2b,
	0x5c, 0x05, 0x07, 0xb9, 0x8d, 0x57, 0x34, 0x58, 0xa0, 0xfe, 0xdb, 0x6d, 0xd8, 0x89, 0x16, 0xdf,
	0x87, 0xdd, 0xe9, 0x7c, 0x15, 0x84, 0xb6, 0x9f, 0x45, 0x58, 0x4e, 0xf8, 0xc4, 0x75, 0xed, 0x69,
	0x88, 0x34, 0xbd, 0xcd, 0x6b, 0xe4, 0xc8, 0x0f, 0x81, 0xfd, 0x8b, 0x95, 0xed, 0x4e, 0x05, 0xc8,
	0x72, 0xf2, 0x75, 0xa8, 0x58, 0xd3, 0x67, 0x46, 0x4c, 0xdc, 0x61, 0xa2, 0x0a, 0x95, 0x85, 0xf0,
	0x31, 0xc3, 0xb1, 0xc8, 0x70, 0x6c, 0x6e, 0xb0, 0xbf, 0x5e, 0x2a, 0x25, 0xef, 0x41, 0x31, 0x74,
	0x16, 0xb6, 0xb7, 0x0a, 0x0f, 0xca, 0xac, 0xf5, 0x1a, 0x94, 0x6d, 0xcb, 0x9f, 0x5f, 0x68, 0x2f,
	0x9c, 0xf0, 0x00, 0x90, 0x54, 0x22, 0xd4, 0x2e, 0x7d, 0xc7, 0xf3, 0x09, 0x17, 0xd5, 0xff, 0x0b,
	0xfa, 0x78, 0x95, 0x61, 0x24, 0x22, 0xcb, 0x00, 0x26, 0x2e, 0xf1, 0xd9, 0xca, 0x72, 0x43, 0xeb,
	0xa0, 0xc6, 0xab, 0xe0, 0xb2, 0x4f, 0xad, 0x70, 0x7a, 0x86, 0x67, 0xde, 0x45, 0x42, 0xad, 0xfe,
	0x55, 0x0e, 0xf2, 0x6c, 0x70, 0x5c, 0xec, 0x99, 0x7d, 0xf1, 0xc8, 0x9a, 0xaf, 0xec, 0xc8, 0xc9,
	0x9b, 0x2c, 0x76, 0x1c, 0x89, 0xc8, 0x1f, 0x40, 0xc1, 0xb7, 0xdc, 0x53, 0x3b, 0xf2, 0xf3, 0xbd,
	0x0d, 0x64, 0x47, 0xc4, 0x4f, 0x82, 0x81, 0x1d, 0xae, 0x96, 0x91, 0x9f, 0x37, 0x11, 0x34, 0x88,
	0x5f, 0xd6, 0xa0, 0xba, 0x6c, 0x2d, 0x07, 0x4b, 0xdb, 0xb7, 0xc8, 0x8b, 0xec, 0xb1, 0x4a, 0xeb,
	0x9d, 0x4d, 0x2c, 0xd4, 0x1a, 0x26, 0x62, 0x04, 0xb4, 0x53, 0x3b, 0xec, 0x7a, 0xa7, 0x51, 0x68,
	0x6f, 0x02, 0xb4, 0x23, 0x16, 0x20, 0x93, 0x05, 0xf6, 0x74, 0xc5, 0xfe, 0x29, 0x6e, 0x6c, 0x32,
	0x23, 0x12, 0x91, 0x7f, 0x02, 0x05, 0x8c, 0xe5, 0xc1, 0xf2, 0xa0, 0xb4, 0xf9, 0xce, 0x89, 0x3f,
	0xde, 0x39, 0x5a, 0x8e, 0x7d, 0xc9, 0x00, 0xda, 0xcc, 0x72, 0x87, 0xc4, 0x5f, 0x6f, 0x43, 0x81,
	0x07, 0x72, 0x0d, 0x0a, 0x53, 0x6f, 0xe5, 0x86, 0xec, 0xf0, 0x02, 0x46, 0x45, 0x8a, 0xff, 0xed,
	0xbb, 0xb9, 0x7b, 0xb9, 0xc3, 0x6d, 0xcc, 0x15, 0x18, 0x43, 0x27, 0x96, 0x33, 0xb7, 0x67, 0x49,
	0x18, 0x70, 0xb4, 0xd4, 0xbf, 0xca, 0xc3, 0x8e, 0x88, 0x38, 0xf9, 0x10, 0xf2, 0x53, 0x6f, 0x26,
	0x70, 0xb3, 0xdb, 0x7a, 0xb0, 0x71, 0xa8, 0x46, 0x7f, 0x54, 0x94, 0xc5, 0x2c, 0x54, 0x13, 0x01,
	0x1f, 0x45, 0x09, 0x03, 0xa9, 0x2c, 0xdf, 0x82, 0xbd, 0x99, 0x1d, 0xf2, 0xfa, 0xf1, 0x44, 0x8e,
	0x93, 0xdf, 0x5f, 0x73, 0x00, 0x19, 0xf1, 0xbb, 0x70, 0x3d, 0xce, 0x7f, 0x22, 0x83, 0x4d, 0xd4,
	0x41, 0x7b, 0x2d, 0x03, 0x5e, 0x83, 0x5a, 0x7f, 0x60, 0x4e, 0x14, 0xd3, 0xd4, 0x7a, 0x43, 0x4c,
	0x74, 0xd2, 0x77, 0x28, 0x0d, 0x1a, 0x63, 0x55, 0xd5, 0x0c, 0x03, 0xcf, 0x29, 0x41, 0x95, 0x32,
	0xe4, 0xe4, 0xa1, 0xa2, 0x77, 0xc7, 0x23, 0x0d, 0x13, 0xa3, 0x0c, 0xbb, 0x2c, 0x81, 0x69, 0x72,
	0x30, 0xd2, 0xbf, 0x40, 0x11, 0xca, 0x08, 0x7b, 0x8f, 0xb4, 0x91, 0xa1, 0x0f, 0xfa, 0x09, 0x63,
	0x9e, 0x18, 0xf5, 0xbe, 0xa9, 0x8d, 0xfa, 0x4a, 0x77, 0xa2, 0x8d, 0x46, 0x83, 0x91, 0x54, 0x20,
	0xc6, 0x8e, 0xa6, 0xb4, 0xb5, 0xd1, 0x64, 0xa4, 0x7d, 0x36, 0xd6, 0x47, 0x28, 0xbd, 0x83, 0x06,
	0x2f, 0x93, 0xc6, 0x87, 0x83, 0x71, 0xbf, 0x2d, 0x15, 0xd1, 0xe0, 0x52, 0xac, 0xac, 0xa7, 0x1b,
	0x3d, 0xc5, 0x54, 0x3b, 0x52, 0x89, 0x36, 0x62, 0x68, 0xa3, 0x47, 0xba, 0xaa, 0x4d, 0x0e, 0xc7,
	0xc6, 0x13, 0xa9, 0x4c, 0xfb, 0xd4, 0x3e, 0x1f, 0xb2, 0x0e, 0x90, 0x77, 0x01, 0xda, 0x8a, 0xa9,
	0x44, 0x0b, 0x55, 0x68, 0xa1, 0xa1, 0x36, 0xea, 0x4d, 0x32, 0xc4, 0xaa, 0xfc, 0x12, 0xdc, 0x1a,
	0x69, 0xbd, 0x81, 0xa9, 0xa1, 0x19, 0xfa, 0x7d, 0x4d, 0x35, 0x69, 0x0d, 0x31, 0x59, 0xa3, 0xbb,
	0xa0, 0x3f, 0x98, 0x18, 0x43, 0x45, 0xd5, 0xa4, 0x5d, 0xb9, 0x0e, 0xfb, 0xf4, 0x35, 0x56, 0x3b,
	0x13, 0x3e, 0xbf, 0xd2, 0x3d, 0xc2, 0xd3, 0x9a, 0x9d, 0x9e, 0xb4, 0x47, 0xba, 0x63, 0xab, 0xd2,
	0x29, 0x34, 0xc3, 0x94, 0x24, 0xd2, 0xdd, 0xc7, 0x91, 0xd6, 0x9e, 0x0c, 0x70, 0x61, 0x25, 0x55,
	0x6d, 0x48, 0xd7, 0xc8, 0xca, 0x6d, 0x8d, 0xf7, 0xde, 0x1d, 0xa8, 0xc7, 0xb8, 0x61, 0x99, 0xf8,
	0x23, 0x92, 0xd2, 0x1d, 0xa1, 0x49, 0x9e, 0x4c, 0xc6, 0xfd, 0x68, 0xf2, 0xba, 0x7c, 0x1b, 0x6e,
	0x66, 0x76, 0x88, 0x36, 0xec, 0xe1, 0xbd, 0x44, 0xde, 0xb9, 0x41, 0xaa, 0xe2, 0xc5, 0x0f, 0xd9,
	0x34, 0x37, 0xeb, 0xff, 0xda, 0x82, 0x52, 0x92, 0x72, 0x30, 0xbf, 0xb9, 0xf6, 0xf3, 0x38, 0xb1,
	0xf3, 0x55, 0x49, 0x88, 0x3e, 0xf1, 0x7c, 0xc4, 0x68, 0x89, 0x33, 0x28, 0x5e, 0x97, 0x98, 0xd4,
	0x04, 0x62, 0x28, 0xc3, 0xce, 0x9e, 0xc6, 0xec, 0x79, 0x26, 0xe1, 0x7c, 0x68, 0x9d, 0x72, 0x49,
	0x50, 0x95, 0x3f, 0x85, 0xb2, 0x35, 0x3f, 0xa5, 0xdc, 0x79, 0xb6, 0xe0, 0x64, 0xb0, 0xdb, 0x7a,
	0x7b, 0x03, 0x28, 0x2b, 0xb1, 0x0c, 0xdd, 0x2a, 0x0b, 0xc4, 0xea, 0xcc, 0x0a, 0xad, 0x81, 0x3b,
	0x17, 0x39, 0xa1, 0x24, 0x1f, 0xc3, 0x5e, 0x70, 0xe1, 0x4e, 0xcf, 0x7c, 0xcf, 0x75, 0xbe, 0x14,
	0xa9, 0xaa, 0xcc, 0xca, 0x5b, 0x9b, 0xc4, 0xc9, 0xba, 0x64, 0xfd, 0xd7, 0x5b, 0x50, 0x10, 0x79,
	0x93, 0x2e, 0xab, 0xd0, 0xf2, 0x43, 0x34, 0x87, 0x28, 0x07, 0x10, 0x18, 0x3b, 0xb6, 0x3b, 0xa3,
	0x6f, 0x61, 0x8b, 0xdb, 0x70, 0x2d, 0xe6, 0xd0, 0x5d, 0xba, 0x06, 0x9d, 0x73, 0x11, 0x3c, 0x25,
	0x8a, 0x2a, 0xc1, 0x9a, 0x4e, 0xe4, 0x79, 0x02, 0x2f, 0xbc, 0x85, 0xf5, 0x62, 0x84, 0x09, 0xd6,
	0x77, 0xed, 0x19, 0x1b, 0xa6, 0x40, 0x97, 0x86, 0x6f, 0x9f, 0xa3, 0xe1, 0xc4, 0x0d, 0x58, 0xa2,
	0xf2, 0x04, 0xcd, 0x1a, 0xa0, 0x91, 0x73, 0x58, 0x9e, 0x7c, 0x0c, 0x05, 0x91, 0x91, 0x71, 0x41,
	0x74, 0x88, 0xfa, 0x4d, 0x17, 0xee, 0x01, 0x48, 0x27, 0x8e, 0xbf, 0x78, 0x6e, 0xf9, 0x76, 0xdb,
	0x7b, 0xee, 0xce, 0x3d, 0x4b, 0x28, 0x2f, 0xd5, 0x7f, 0x9f, 0x83, 0xea, 0x5a, 0x42, 0xc6, 0x64,
	0xb2, 0xb4, 0x93, 0x4a, 0xe3, 0xc1, 0x15, 0xf3, 0x79, 0x73, 0x88, 0xb2, 0x72, 0x17, 0xca, 0x5e,
	0x72, 0x31, 0x50, 0x2a, 0xab, 0xb4, 0x3e, 0xbc, 0xaa, 0xa2, 0x74, 0x47, 0xaf, 0xc2, 0x4b, 0xd6,
	0x7c, 0xae, 0x9e, 0x39, 0xf3, 0x59, 0x42, 0x0c, 0x8c, 0xd5, 0x74, 0x6a, 0xdb, 0x33, 0x34, 0x12,
	0x9b, 0xb4, 0xfe, 0x87, 0x2d, 0x28, 0xa7, 0x22, 0x6b, 0xc0, 0x43, 0xfb, 0x9d, 0xaf, 0xc1, 0x0e,
	0x3d, 0x85, 0x86, 0x22, 0x4f, 0x15, 0xd6, 0x51, 0x2b, 0xcc, 0x9b, 0xd6, 0x3e, 0xc5, 0x2b, 0xd6,
	0x3e, 0x7c, 0xa7, 0xb4, 0x96, 0xde, 0x95, 0xee, 0x94, 0xcc, 0xa1, 0xeb, 0xf7, 0x21, 0xcf, 0x06,
	0x44, 0x74, 0x9d, 0x79, 0x41, 0xe8, 0x5a, 0x0b, 0x91, 0xd5, 0xcb, 0xe4, 0xf3, 0xa5, 0xe7, 0x87,
	0x8c, 0xad, 0x02, 0x07, 0xce, 0x3c, 0x88, 0x8e, 0xfe, 0x17, 0x3c, 0x4f, 0x72, 0x25, 0x16, 0x42,
	0x2c, 0x6f, 0x02, 0x14, 0xca, 0x6d, 0x58, 0x15, 0x09, 0xc9, 0x26, 0x57, 0x45, 0xc7, 0x50, 0x5d,
	0x85, 0xce, 0x3c, 0x42, 0x7b, 0x10, 0xb9, 0xee, 0xbd, 0xcd, 0xb5, 0x8c, 0x53, 0x69, 0x52, 0x16,
	0xda, 0x0b, 0x3e, 0xda, 0xca, 0xb7, 0x69, 0xb3, 0x57, 0x54, 0x66, 0xa6, 0xd2, 0x72, 0x1b, 0x4a,
	0x53, 0x6b, 0x69, 0x4d, 0xe9, 0xae, 0x17, 0x95, 0x46, 0x6b, 0x73, 0x45, 0x6a, 0x24, 0x29, 0xf7,
	0xa1, 0x86, 0x75, 0xe7, 0x89, 0x73, 0xba, 0x8a, 0xb0, 0x29, 0x9a, 0x91, 0x0f, 0xae, 0xa0, 0x2a,
	0x2b, 0x2e, 0x77, 0x00, 0x08, 0x29, 0x4e, 0x80, 0xfc, 0x01, 0xa2, 0x27, 0xb7, 0x61, 0xc4, 0x44,
	0xca, 0x8c, 0x44, 0x96, 0x1c, 0x1e, 0x15, 0xb5, 0x51, 0x87, 0x22, 0xff, 0x14, 0x76, 0xe6, 0xce,
	0xc2, 0x09, 0x83, 0x08, 0x4b, 0xef, 0x6e, 0xae, 0xb7, 0xcb, 0x72, 0xa4, 0x61, 0x66, 0x9f, 0x3b,
	0x88, 0xeb, 0xf2, 0x55, 0x35, 0xb4, 0x59, 0x0e, 0xbb, 0xa4, 0x4a, 0xd6, 0xa3, 0x88, 0xc1, 0x0c,
	0x22, 0x31, 0x6a, 0xce, 0xb9, 0x5c, 0x25, 0x48, 0x6e, 0xd7, 0x7f, 0x0e, 0x95, 0xac, 0xc3, 0xd6,
	0x79, 0x31, 0x04, 0xb1, 0xea, 0xf2, 0xb1, 0xc9, 0x12, 0xdc, 0x44, 0x58, 0x38, 0xae, 0xb3, 0x58,
	0x2d, 0x18, 0xc4, 0x82, 0x60, 0xbd, 0x60, 0x42, 0x9e, 0x09, 0x08, 0x6a, 0xcc, 0x9e, 0x58, 0x1b,
	0xb2, 0x93, 0xb6, 0xeb, 0x9f, 0x42, 0x29, 0xf1, 0xe3, 0x1d, 0xd8, 0x77, 0x3d, 0x94, 0xb7, 0xe6,
	0x31, 0x49, 0x77, 0x45, 0x77, 0x47, 0xb2, 0x79, 0x4a, 0xa3, 0x14, 0x2c, 0xb8, 0xe7, 0x87, 0xab,
	0xf9, 0x3c, 0x52, 0xf0, 0xbb, 0x1c, 0xd4, 0xd6, 0xdd, 0x87, 0x4b, 0x9c, 0x63, 0x1e, 0xf6, 0x7c,
	0xe6, 0xe0, 0x13, 0x2d, 0xb0, 0x98, 0x99, 0x73, 0x1e, 0x28, 0xd3, 0x7d, 0x12, 0xd8, 0xbe, 0x63,
	0xcd, 0xfb, 0xab, 0xc5, 0x53, 0xcc, 0x88, 0xc2, 0x2f, 0x58, 0x28, 0x3d, 0xf7, 0xfc, 0xf9, 0xec,
	0x31, 0xf6, 0x8c, 0x7d, 0x3a, 0xe1, 0xee, 0xe5, 0x24, 0x53, 0x8a, 0x2b, 0x27, 0x34, 0xf7, 0xd2,
	0x99, 0xf3, 0x5a, 0x6d, 0x34, 0x39, 0x37, 0x11, 0x65, 0xba, 0x37, 0x03, 0x6f, 0x85, 0xe9, 0xa6,
	0x63, 0x05, 0x67, 0xdc, 0x17, 0x30, 0xf3, 0xe5, 0x5e, 0x7c, 0x8f, 0x27, 0x5e, 0x86, 0x5b, 0xf1,
	0x84, 0x7a, 0x49, 0x9b, 0xc4, 0x0c, 0x75, 0x90, 0x63, 0x06, 0x23, 0xd5, 0x7a, 0x8d, 0xe7, 0x4c,
	0x28, 0x3b, 0x2e, 0xde, 0x05, 0x27, 0x16, 0x63, 0x80, 0xd0, 0xa9, 0x7c, 0x4b, 0xa8, 0x37, 0xf5,
	0x58, 0x51, 0x92, 0x89, 0x20, 0xbe, 0x9c, 0x30, 0x13, 0x0d, 0x89, 0x50, 0x21, 0x42, 0x7d, 0x08,
	0xe5, 0x35, 0xde, 0x0c, 0x0a, 0x30, 0x6b, 0x61, 0x85, 0x13, 0x5d, 0x8f, 0xe8, 0x23, 0x67, 0x79,
	0xfe, 0x40, 0x99, 0xcd, 0x30, 0x39, 0x04, 0x51, 0xaa, 0x16, 0xc4, 0xf7, 0x63, 0x22, 0xa7, 0xeb,
	0xba, 0x27, 0x2a, 0xcd, 0x28, 0x52, 0x2e, 0xb5, 0x7f, 0x5b, 0xdf, 0xaa, 0xfd, 0x4b, 0x2a, 0x6f,
	0x81, 0x17, 0xfc, 0x7c, 0xca, 0xf0, 0x21, 0x1c, 0xe4, 0xeb, 0x7f, 0xc6, 0x0e, 0x36, 0x8a, 0x21,
	0x74, 0x16, 0xc2, 0x12, 0xaf, 0x0a, 0xc3, 0xf9, 0x52, 0x2c, 0x56, 0xe3, 0x3a, 0xc3, 0x7a, 0xc1,
	0x45, 0x10, 0x53, 0xb7, 0x99, 0x8a, 0x75, 0x3a, 0x51, 0x85, 0xf7, 0x98, 0x9e, 0x63, 0xba, 0xd0,
	0x60, 0x5a, 0xa7, 0x4c, 0xcb, 0x67, 0x78, 0xd5, 0xa4, 0x05, 0x16, 0x0b, 0xd7, 0xe4, 0x06, 0xd4,
	0x91, 0x3e, 0x58, 0x85, 0x98, 0x55, 0xdc, 0x99, 0xe3, 0x9e, 0x8e, 0xb0, 0x8f, 0x1e, 0x51, 0xdd,
	0x1f, 0x84, 0x01, 0xa3, 0xb2, 0x46, 0xb7, 0xe1, 0x3a, 0xcf, 0x63, 0xac, 0x7e, 0xec, 0x84, 0xa9,
	0x98, 0x59, 0x20, 0x3a, 0x31, 0x2f, 0x5c, 0x62, 0x3a, 0xd6, 0x01, 0xe2, 0x38, 0x5c, 0xc4, 0xa8,
	0x6c, 0x82, 0x72, 0x66, 0x46, 0x8f, 0xde, 0x41, 0xc4, 0x0c, 0x64, 0x0e, 0x80, 0xad, 0x0f, 0xeb,
	0xa9, 0x30, 0xed, 0x15, 0xb8, 0x4d, 0x9b, 0x88, 0xef, 0x2d, 0x66, 0x1f, 0xda, 0x3e, 0xb7, 0x35,
	0x0c, 0xf3, 0x1a, 0xc5, 0x28, 0xb2, 0x30, 0x25, 0x9e, 0x16, 0x59, 0x85, 0x21, 0x5f, 0xab, 0xef,
	0xc3, 0x8e, 0xf8, 0x5e, 0x03, 0x49, 0xb5, 0xf1, 0x9b, 0x2d, 0xc8, 0xb3, 0x8f, 0x6e, 0x43, 0x35,
	0xae, 0x3f, 0x2f, 0xbf, 0xa6, 0x60, 0x89, 0x3e, 0x36, 0xf5, 0xae, 0xfe, 0x05, 0x57, 0xbf, 0x06,
	0xb6, 0x12, 0x48, 0xa1, 0xbe, 0x82, 0xea, 0x61, 0xec, 0x09, 0xa8, 0x9f, 0xc0, 0x3a, 0x5d, 0x55,
	0xb0, 0xc6, 0xd6, 0x4d, 0x1d, 0xbf, 0xb7, 0xa9, 0x9c, 0xc5, 0x4a, 0xf7, 0xa1, 0x7e, 0x34, 0x16,
	0x35, 0x33, 0x36, 0x13, 0xc8, 0x42, 0xcd, 0x8a, 0x6e, 0x98, 0xba, 0x6a, 0x60, 0x1f, 0x81, 0x85,
	0x79, 0x0f, 0x9b, 0x11, 0xe5, 0x08, 0x05, 0x0a, 0x78, 0xec, 0x9d, 0xae, 0xde, 0xd3, 0x4d, 0x03,
	0x1b, 0x07, 0x1c, 0x8b, 0x1a, 0x5a, 0x2a, 0xd6, 0xff, 0x59, 0x80, 0x52, 0xd2, 0x44, 0x7e, 0x0c,
	0x39, 0x6b, 0x3a, 0x8f, 0x2e, 0xca, 0x77, 0xae, 0xd0, 0x7e, 0x36, 0x15, 0xb5, 0x4b, 0xa6, 0xf5,
	0xe6, 0xb3, 0xae, 0x37, 0x7d, 0x36, 0xd4, 0xfb, 0x51, 0x08, 0x88, 0xb2, 0x3a, 0xa6, 0xe5, 0xe3,
	0xb0, 0x40, 0x3e, 0xcd, 0xb7, 0x02, 0x9b, 0x88, 0x85, 0x98, 0x88, 0x8c, 0x09, 0x71, 0x87, 0x63,
	0xe5, 0x4f, 0x79, 0xc8, 0x91, 0xe6, 0xaf, 0xbf, 0x69, 0x45, 0x25, 0x91, 0x08, 0x3e, 0x13, 0x6a,
	0xfc, 0x20, 0x97, 0xd4, 0xdb, 0x39, 0x0e, 0xa3, 0x4f, 0xae, 0x78, 0x00, 0x7e, 0xa2, 0x4b, 0x0b,
	0x70, 0x6c, 0x6c, 0x83, 0xa9, 0xc7, 0x4f, 0x84, 0x9b, 0x5e, 0xf5, 0x6b, 0xda, 0x0c, 0x12, 0xc6,
	0x6b, 0x8b, 0x6a, 0xe0, 0xf8, 0x19, 0x85, 0x0f, 0x7b, 0xb5, 0x97, 0x97, 0xfa, 0xaf, 0xb0, 0x4a,
	0x17, 0xba, 0x30, 0xc3, 0x7b, 0x27, 0x27, 0x81, 0x1d, 0x46, 0x46, 0x58, 0xbb, 0xb3, 0xaa, 0x58,
	0x0f, 0x00, 0x42, 0x78, 0xe1, 0x04, 0x9c, 0x71, 0x73, 0x5c, 0x33, 0x7d, 0x74, 0xd5, 0x5d, 0x0f,
	0x13, 0x0d, 0xe4, 0x12, 0x73, 0x1e, 0x50, 0x2c, 0x3a, 0x3e, 0x56, 0xa6, 0x5c, 0xd3, 0x37, 0x0e,
	0xa1, 0xb6, 0x6e, 0xa6, 0x57, 0x61, 0x3f, 0x06, 0xf6, 0xa5, 0x8e, 0xef, 0xd2, 0x83, 0x21, 0x7a,
	0xc8, 0xe8, 0x28, 0x3f, 0x92, 0xb6, 0x1a, 0xbf, 0xdc, 0x02, 0xc8, 0xac, 0xf3, 0x32, 0xc8, 0xb1,
	0x06, 0xea, 0x3d, 0x75, 0x83, 0x7a, 0xd8, 0xac, 0x74, 0x09, 0xf2, 0xd4, 0xea, 0x61, 0x60, 0x94,
	0xa1, 0xf0, 0x18, 0x95, 0x6b, 0x18, 0x11, 0x0c, 0xe2, 0xae, 0x66, 0x52, 0x6f, 0x8d, 0xe4, 0x91,
	0xd2, 0x3f, 0xd2, 0x30, 0x0a, 0x70, 0x68, 0x68, 0xe6, 0x78, 0x88, 0x01, 0x80, 0x43, 0x2a, 0x47,
	0x87, 0x02, 0xfd, 0x47, 0x9a, 0xd9, 0x1d, 0x1c, 0x61, 0x9f, 0x8c, 0x7b, 0x31, 0x34, 0x75, 0x8c,
	0x6a, 0x9e, 0x48, 0xa5, 0xfa, 0x1f, 0xb7, 0xb0, 0x63, 0xc8, 0x3e, 0x84, 0x60, 0xb5, 0xcf, 0x0f,
	0x29, 0x99, 0x7c, 0xfc, 0xe1, 0x15, 0x1f, 0x53, 0xc4, 0x07, 0x29, 0x68, 0xf8, 0x50, 0x4e, 0x3e,
	0xf0, 0x76, 0x4b, 0x7a, 0x50, 0xc4, 0x38, 0x6e, 0xec, 0x52, 0x12, 0xe0, 0x46, 0x36, 0x9a, 0xe2,
	0x90, 0xcf, 0x7c, 0x53, 0x4d, 0x51, 0xc1, 0x84, 0x60, 0x68, 0x11, 0x21, 0x87, 0x69, 0x51, 0xe6,
	0x83, 0x68, 0x93, 0x2c, 0x3d, 0xdf, 0x98, 0xc2, 0xde, 0xa5, 0x4e, 0x4f, 0x7e, 0x0d, 0x6e, 0x25,
	0x0f, 0x1a, 0x4f, 0xfa, 0x6a, 0x67, 0x34, 0xe8, 0x47, 0xe9, 0xe6, 0xd2, 0x1e, 0xd8, 0xba, 0x26,
	0xce, 0x8f, 0x8f, 0xe8, 0x69, 0xb7, 0x06, 0x65, 0xa6, 0x1c, 0x2a, 0xea, 0xb1, 0xb0, 0xf3, 0xc3,
	0xee, 0xd8, 0xe8, 0x48, 0xb9, 0xc6, 0x43, 0x28, 0x25, 0x6f, 0x83, 0x68, 0xdd, 0xfe, 0x60, 0xd4,
	0x53, 0xba, 0x51, 0x9e, 0x19, 0x3c, 0xa6, 0xde, 0x7e, 0x8b, 0xd8, 0x69, 0x3c, 0xc2, 0xbd, 0x22,
	0xb9, 0xa3, 0x1f, 0x75, 0x70, 0x5c, 0xa4, 0x07, 0x08, 0x1e, 0x23, 0x4f, 0xb9, 0x31, 0x81, 0x72,
	0x8a, 0xa5, 0xec, 0xbb, 0xf3, 0x37, 0xc1, 0x08, 0x81, 0x20, 0x20, 0x14, 0x8d, 0x5a, 0xb8, 0x27,
	0x31, 0xba, 0x2f, 0x5c, 0xaf, 0x8e, 0xd4, 0xfb, 0x2d, 0xe1, 0x7a, 0x1c, 0xbe, 0xff, 0x40, 0x2a,
	0x34, 0xfe, 0x5e, 0x80, 0x4a, 0xf6, 0xb2, 0x7c, 0x05, 0x6e, 0xc4, 0x6b, 0x44, 0xe9, 0xf1, 0x6b,
	0x09, 0xb9, 0x08, 0x39, 0x44, 0x0b, 0xea, 0x46, 0x83, 0xe0, 0x60, 0x82, 0x29, 0x78, 0x88, 0x89,
	0x99, 0x50, 0x87, 0x53, 0xc3, 0xb1, 0x89, 0x2b, 0xe0, 0x14, 0x0e, 0xd2, 0xa9, 0x5c, 0x06, 0x90,
	0x3b, 0xf4, 0xd4, 0x21, 0xc6, 0x29, 0x03, 0xb5, 0x39, 0x45, 0xd4, 0xd6, 0xd7, 0x3e, 0x37, 0xa5,
	0x12, 0xbd, 0xd6, 0x44, 0x1f, 0x29, 0x4b, 0x91, 0x7c, 0x8c, 0xd4, 0xe1, 0x08, 0xb3, 0xf3, 0x60,
	0x6c, 0x48, 0x80, 0x17, 0xd9, 0x8d, 0x0c, 0x21, 0x65, 0x2d, 0x47, 0xac, 0xc7, 0xda, 0x13, 0x81,
	0xfc, 0x6a, 0xc4, 0x1a, 0x13, 0x52, 0xd6, 0x0a, 0x21, 0x09, 0x67, 0xa2, 0xc7, 0x21, 0x49, 0xc2,
	0xfa, 0xec, 0x7a, 0xfa, 0x9d, 0x32, 0xee, 0xa5, 0xc1, 0xb3, 0x4f, 0xaf, 0x50, 0x3c, 0x4c, 0xa7,
	0x6f, 0x66, 0xa2, 0xe8, 0x80, 0x4e, 0x28, 0xc6, 0x29, 0xc3, 0xad, 0xb5, 0xd0, 0xaa, 0xd3, 0xbf,
	0x02, 0xe2, 0xaf, 0x94, 0xe9, 0x36, 0x5d, 0x5d, 0x43, 0x4d, 0x1b, 0xb5, 0xe8, 0xd7, 0x90, 0xc0,
	0xf4, 0x5d, 0x7a, 0x35, 0x5a, 0x23, 0xa5, 0xec, 0x2f, 0x91, 0x7f, 0xfb, 0x03, 0xc4, 0xf5, 0x1d,
	0xf1, 0xe6, 0x36, 0xc8, 0xec, 0xe8, 0x7b, 0xe4, 0x05, 0x06, 0xa4, 0xd2, 0xed, 0xd2, 0x8b, 0x95,
	0x74, 0x97, 0x9e, 0x80, 0xb2, 0x94, 0x94, 0xf9, 0x65, 0xce, 0x07, 0x1c, 0x22, 0xaf, 0xd1, 0xe9,
	0x78, 0x98, 0x4e, 0xbf, 0x4a, 0x58, 0xef, 0x69, 0x6d, 0x5d, 0x31, 0x54, 0xa5, 0x2f, 0xfd, 0x80,
	0xa2, 0x2b, 0xf9, 0x4c, 0xd9, 0xbe, 0x4f, 0xbb, 0x60, 0xfa, 0x60, 0x68, 0xe2, 0x7d, 0xfa, 0x85,
	0x26, 0xdd, 0xa3, 0xed, 0xaf, 0x91, 0x52, 0xf6, 0xd7, 0xc9, 0x4d, 0x78, 0x2b, 0x8f, 0xcc, 0xe8,
	0xd5, 0xe9, 0x4d, 0x72, 0x53, 0x86, 0x90, 0xb2, 0xbe, 0x41, 0x1b, 0xd0, 0xfa, 0xf1, 0xf3, 0xd4,
	0xdb, 0xb4, 0x81, 0xe4, 0x33, 0x65, 0x7b, 0x8b, 0x34, 0x2a, 0x87, 0x83, 0x44, 0x63, 0x93, 0x34,
	0x66, 0x08, 0x29, 0xeb, 0x0f, 0x0f, 0xcb, 0x87, 0xc5, 0x63, 0x91, 0xad, 0xfe, 0x13, 0x00, 0x00,
	0xff, 0xff, 0xd7, 0x27, 0xf8, 0xd6, 0x53, 0x1b, 0x00, 0x00,
}
